<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>4D+ Optimization: Beyond Human Visualization | GLM Explainer</title>
  <!-- Plotly.js for 3D projections -->
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      line-height: 1.6;
      color: #2c3e50;
      background: #f8f9fa;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 30px;
    }

    header h1 {
      font-size: 1.8em;
      color: #2c3e50;
      margin-bottom: 10px;
    }

    header p {
      color: #666;
      font-size: 1.1em;
    }

    .nav-links {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 15px;
      flex-wrap: wrap;
    }

    .nav-links a {
      color: #667eea;
      text-decoration: none;
      font-weight: 500;
    }

    .nav-links a:hover {
      text-decoration: underline;
    }

    .nav-links a.current {
      color: #2c3e50;
      font-weight: 600;
    }

    .visualization-card {
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      padding: 25px;
      margin-bottom: 20px;
    }

    .viz-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 15px;
    }

    .viz-title {
      font-size: 1.2em;
      font-weight: 600;
      color: #2c3e50;
    }

    /* Key insight banner */
    .insight-banner {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px 25px;
      border-radius: 10px;
      margin-bottom: 25px;
      text-align: center;
    }

    .insight-banner h2 {
      font-size: 1.3em;
      margin-bottom: 10px;
    }

    .insight-banner p {
      font-size: 1em;
      opacity: 0.95;
    }

    /* Dual panel layout */
    .panel-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    @media (max-width: 900px) {
      .panel-grid {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 15px;
    }

    .panel h4 {
      margin: 0 0 10px 0;
      font-size: 0.95em;
      color: #666;
      text-align: center;
    }

    /* Projection selector */
    .projection-selector {
      background: #e8f4fd;
      border: 1px solid #bee5eb;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
    }

    .projection-selector h4 {
      color: #0c5460;
      margin-bottom: 10px;
      font-size: 0.95em;
    }

    .projection-options {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
    }

    .projection-options label {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      color: #0c5460;
      font-size: 0.9em;
    }

    /* Plotly container */
    #plotly-projection {
      width: 100%;
      height: 380px;
    }

    /* Manual controls */
    .manual-controls {
      background: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: 8px;
      padding: 20px;
      margin-top: 15px;
    }

    .manual-controls h4 {
      color: #856404;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .manual-controls h4::before {
      content: 'üëÜ';
    }

    .slider-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px 25px;
    }

    @media (max-width: 600px) {
      .slider-grid {
        grid-template-columns: 1fr;
      }
    }

    .slider-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .slider-row label {
      font-weight: 500;
      color: #666;
      min-width: 80px;
      font-size: 0.9em;
    }

    .slider-row input[type="range"] {
      flex: 1;
      height: 6px;
      border-radius: 3px;
      background: #ddd;
      outline: none;
      -webkit-appearance: none;
    }

    .slider-row input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #e74c3c;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .slider-value {
      font-family: 'SF Mono', Monaco, monospace;
      font-weight: 600;
      min-width: 50px;
      text-align: right;
      font-size: 0.85em;
    }

    /* Mode toggle */
    .mode-toggle {
      display: flex;
      background: #e0e0e0;
      border-radius: 8px;
      padding: 4px;
      margin-bottom: 20px;
    }

    .mode-btn {
      flex: 1;
      padding: 10px 20px;
      border: none;
      background: transparent;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      color: #666;
      transition: all 0.2s;
    }

    .mode-btn.active {
      background: white;
      color: #667eea;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .mode-btn:hover:not(.active) {
      color: #2c3e50;
    }

    /* Algorithm controls */
    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 20px;
      align-items: center;
    }

    .controls.hidden {
      display: none;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .control-group label {
      font-size: 0.9em;
      color: #666;
    }

    select {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 6px;
      background: white;
      font-size: 0.9em;
      cursor: pointer;
    }

    button {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s;
    }

    button.primary {
      background: #667eea;
      color: white;
    }

    button.primary:hover {
      background: #5a6fd6;
    }

    button.secondary {
      background: #95a5a6;
      color: white;
    }

    button.secondary:hover {
      background: #7f8c8d;
    }

    /* Stats display */
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 15px;
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid #eee;
    }

    .stat-item {
      text-align: center;
    }

    .stat-item .label {
      font-size: 0.8em;
      color: #666;
      margin-bottom: 4px;
    }

    .stat-item .value {
      font-size: 1.1em;
      font-weight: 600;
      color: #2c3e50;
      font-family: 'SF Mono', Monaco, monospace;
    }

    /* Algorithm info */
    .algorithm-info {
      background: #e8f4fd;
      border: 1px solid #bee5eb;
      border-radius: 8px;
      padding: 15px;
      margin-top: 15px;
    }

    .algorithm-info.hidden {
      display: none;
    }

    .algorithm-info h4 {
      color: #0c5460;
      margin-bottom: 8px;
    }

    .algorithm-info p {
      color: #0c5460;
      font-size: 0.9em;
    }

    /* Dimension comparison table */
    .dimension-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      font-size: 0.9em;
    }

    .dimension-table th,
    .dimension-table td {
      padding: 12px 15px;
      text-align: center;
      border-bottom: 1px solid #eee;
    }

    .dimension-table th {
      background: #667eea;
      color: white;
      font-weight: 600;
    }

    .dimension-table tr:nth-child(even) {
      background: #f8f9fa;
    }

    .dimension-table tr:hover {
      background: #e8f4fd;
    }

    .dimension-table .highlight {
      background: #fff3cd;
      font-weight: 600;
    }

    /* Explanation section */
    .explanation {
      background: #f8f9fa;
      border-left: 4px solid #667eea;
      padding: 20px;
      margin-top: 20px;
      border-radius: 0 8px 8px 0;
    }

    .explanation h3 {
      color: #2c3e50;
      margin-bottom: 10px;
    }

    .explanation p {
      color: #666;
      margin-bottom: 10px;
    }

    .explanation ul {
      color: #666;
      margin-left: 20px;
    }

    .explanation li {
      margin-bottom: 5px;
    }

    .key-point {
      background: white;
      border: 2px solid #27ae60;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
    }

    .key-point h4 {
      color: #27ae60;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .key-point h4::before {
      content: '‚úì';
      font-weight: bold;
    }

    .key-point p {
      color: #2c3e50;
      margin: 0;
    }

    /* Footer */
    footer {
      text-align: center;
      padding: 20px;
      color: #666;
      font-size: 0.9em;
    }

    footer a {
      color: #667eea;
      text-decoration: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>4D+ Optimization: Beyond Human Visualization</h1>
      <p>Four parameters: intercept (Œ≤‚ÇÄ) and three slopes (Œ≤‚ÇÅ, Œ≤‚ÇÇ, Œ≤‚ÇÉ)</p>
      <div class="nav-links">
        <a href="index.html">1D (Mean Only)</a>
        <a href="2d.html">2D (Line Fit)</a>
        <a href="3d.html">3D (Multiple Regression)</a>
        <a href="4d.html" class="current">4D+ (Beyond Visualisation)</a>
        <a href="multi-optima.html">Multi-Optima</a>
      </div>
    </header>

    <!-- Key insight banner -->
    <div class="insight-banner">
      <h2>We've Hit the Visualization Wall</h2>
      <p>With 4 parameters, we need 5 dimensions to show the likelihood surface (4 for parameters + 1 for likelihood value).<br>
      Humans can only see in 3D ‚Äî but the algorithms don't care. They work identically in 4D, 40D, or 400D.</p>
    </div>

    <div class="visualization-card">
      <div class="viz-header">
        <span class="viz-title">Multiple Regression: y = Œ≤‚ÇÄ + Œ≤‚ÇÅx‚ÇÅ + Œ≤‚ÇÇx‚ÇÇ + Œ≤‚ÇÉx‚ÇÉ</span>
      </div>

      <!-- Mode toggle -->
      <div class="mode-toggle">
        <button class="mode-btn active" data-mode="manual">Try It Yourself</button>
        <button class="mode-btn" data-mode="algorithm">Watch Algorithm</button>
      </div>

      <!-- Projection selector -->
      <div class="projection-selector">
        <h4>Since we can't see 4D, choose a 3D projection (fixing one parameter):</h4>
        <div class="projection-options">
          <label>
            <input type="radio" name="projection" value="b0" checked>
            Fix Œ≤‚ÇÄ ‚Üí Show (Œ≤‚ÇÅ, Œ≤‚ÇÇ, Œ≤‚ÇÉ)
          </label>
          <label>
            <input type="radio" name="projection" value="b1">
            Fix Œ≤‚ÇÅ ‚Üí Show (Œ≤‚ÇÄ, Œ≤‚ÇÇ, Œ≤‚ÇÉ)
          </label>
          <label>
            <input type="radio" name="projection" value="b2">
            Fix Œ≤‚ÇÇ ‚Üí Show (Œ≤‚ÇÄ, Œ≤‚ÇÅ, Œ≤‚ÇÉ)
          </label>
          <label>
            <input type="radio" name="projection" value="b3">
            Fix Œ≤‚ÇÉ ‚Üí Show (Œ≤‚ÇÄ, Œ≤‚ÇÅ, Œ≤‚ÇÇ)
          </label>
        </div>
      </div>

      <!-- Visualization panels -->
      <div class="panel-grid">
        <div class="panel">
          <h4>3D Projection of 4D Likelihood</h4>
          <div id="plotly-projection"></div>
        </div>
        <div class="panel">
          <h4>Algorithm Progress</h4>
          <canvas id="progress-canvas"></canvas>
          <div id="progress-info" style="margin-top: 10px; font-size: 0.85em; color: #666; text-align: center;">
            Watch the algorithm navigate 4D space ‚Äî shown here as distance from MLE over iterations
          </div>
        </div>
      </div>

      <!-- Manual mode controls -->
      <div class="manual-controls" id="manual-controls">
        <h4>Navigate 4D Parameter Space</h4>
        <p style="margin-bottom: 15px; color: #856404;">Adjust four sliders simultaneously. Notice how hard it is to find the optimal combination!</p>

        <div class="slider-grid">
          <div class="slider-row">
            <label>Œ≤‚ÇÄ (intercept):</label>
            <input type="range" id="b0-slider" min="-10" max="20" value="5" step="0.2">
            <span class="slider-value" id="b0-value">5.0</span>
          </div>

          <div class="slider-row">
            <label>Œ≤‚ÇÅ (slope x‚ÇÅ):</label>
            <input type="range" id="b1-slider" min="-5" max="5" value="0" step="0.1">
            <span class="slider-value" id="b1-value">0.0</span>
          </div>

          <div class="slider-row">
            <label>Œ≤‚ÇÇ (slope x‚ÇÇ):</label>
            <input type="range" id="b2-slider" min="-5" max="5" value="0" step="0.1">
            <span class="slider-value" id="b2-value">0.0</span>
          </div>

          <div class="slider-row">
            <label>Œ≤‚ÇÉ (slope x‚ÇÉ):</label>
            <input type="range" id="b3-slider" min="-5" max="5" value="0" step="0.1">
            <span class="slider-value" id="b3-value">0.0</span>
          </div>
        </div>
      </div>

      <!-- Algorithm mode controls -->
      <div class="controls hidden" id="algorithm-controls">
        <div class="control-group">
          <label for="algorithm-select">Algorithm:</label>
          <select id="algorithm-select">
            <option value="analytic">Analytic (OLS)</option>
            <option value="newton">Newton-Raphson</option>
            <option value="gradient">Gradient Descent</option>
          </select>
        </div>

        <button class="primary" id="start-btn">Start</button>
        <button class="secondary" id="reset-btn">Reset</button>
      </div>

      <!-- Algorithm info -->
      <div class="algorithm-info hidden" id="algorithm-info">
        <h4 id="algo-name">Analytic Solution</h4>
        <p id="algo-desc">Computes the exact MLE using 4√ó4 matrix inversion: Œ≤ = (X'X)‚Åª¬πX'y</p>
      </div>

      <!-- Stats display -->
      <div class="stats">
        <div class="stat-item">
          <div class="label">Œ≤‚ÇÄ</div>
          <div class="value" id="current-b0">--</div>
        </div>
        <div class="stat-item">
          <div class="label">Œ≤‚ÇÅ</div>
          <div class="value" id="current-b1">--</div>
        </div>
        <div class="stat-item">
          <div class="label">Œ≤‚ÇÇ</div>
          <div class="value" id="current-b2">--</div>
        </div>
        <div class="stat-item">
          <div class="label">Œ≤‚ÇÉ</div>
          <div class="value" id="current-b3">--</div>
        </div>
        <div class="stat-item">
          <div class="label">Log-‚Ñì</div>
          <div class="value" id="current-ll">--</div>
        </div>
        <div class="stat-item">
          <div class="label">Iterations</div>
          <div class="value" id="iteration-count">0</div>
        </div>
      </div>
    </div>

    <!-- Dimension comparison table -->
    <div class="visualization-card">
      <h3 style="margin-bottom: 15px;">The Dimensionality Challenge</h3>
      <table class="dimension-table">
        <thead>
          <tr>
            <th>Parameters</th>
            <th>Likelihood Space</th>
            <th>Can We Visualize?</th>
            <th>Typical Use Case</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>1 (mean only)</td>
            <td>2D (1 param + likelihood)</td>
            <td>Yes ‚Äî a curve</td>
            <td>Simple estimation</td>
          </tr>
          <tr>
            <td>2 (line fit)</td>
            <td>3D (2 params + likelihood)</td>
            <td>Yes ‚Äî a surface</td>
            <td>Simple linear regression</td>
          </tr>
          <tr>
            <td>3 (multiple reg.)</td>
            <td>4D (3 params + likelihood)</td>
            <td>Barely ‚Äî color as 4th dim</td>
            <td>Multiple regression</td>
          </tr>
          <tr class="highlight">
            <td>4 (this page)</td>
            <td>5D (4 params + likelihood)</td>
            <td>No ‚Äî must use projections</td>
            <td>Multiple regression</td>
          </tr>
          <tr>
            <td>10‚Äì50</td>
            <td>11D‚Äì51D</td>
            <td>No</td>
            <td>Typical statistical GLMs</td>
          </tr>
          <tr>
            <td>100‚Äì1,000</td>
            <td>101D‚Äì1,001D</td>
            <td>No</td>
            <td>Large surveys, genomics</td>
          </tr>
          <tr>
            <td>10‚Å∑‚Äì10‚Å∏</td>
            <td>Tens of millions D</td>
            <td>No</td>
            <td>Image classifiers, small NNs</td>
          </tr>
          <tr>
            <td>10‚Åπ‚Äì10¬π¬≤</td>
            <td>Billions‚Äìtrillions D</td>
            <td>No</td>
            <td>Large language models (GPT, Claude)</td>
          </tr>
        </tbody>
      </table>
      <p style="font-size: 0.85em; color: #666; margin-top: 15px;">
        <strong>Note:</strong> Statistical models (GLMs, mixed models) typically have tens to hundreds of parameters,
        carefully chosen based on domain knowledge. Machine learning and AI models range from millions (image classifiers)
        to trillions (large language models like GPT-4). The fundamental optimization principles are the same ‚Äî
        follow the gradient ‚Äî but specialized algorithms (SGD, Adam) that work on mini-batches are needed at scale.
      </p>
    </div>

    <!-- Explanation -->
    <div class="explanation">
      <h3>Why This Matters</h3>

      <div class="key-point">
        <h4>The Maths Doesn't Change</h4>
        <p>Whether we have 2 parameters or 200, the gradient still points toward the maximum, the Hessian still captures the curvature, and Newton-Raphson still converges in a few steps. The algorithm is dimension-agnostic.</p>
      </div>

      <p>Consider what the algorithms are doing in 4D:</p>
      <ul>
        <li><strong>Gradient Descent:</strong> Computes 4 partial derivatives (‚àÇ‚Ñì/‚àÇŒ≤‚ÇÄ, ‚àÇ‚Ñì/‚àÇŒ≤‚ÇÅ, ‚àÇ‚Ñì/‚àÇŒ≤‚ÇÇ, ‚àÇ‚Ñì/‚àÇŒ≤‚ÇÉ) and moves in that direction</li>
        <li><strong>Newton-Raphson:</strong> Uses a 4√ó4 Hessian matrix to find the step that accounts for curvature in all directions simultaneously</li>
        <li><strong>OLS Analytic:</strong> Inverts a 4√ó4 matrix (X'X) ‚Äî same formula as 2D, just bigger matrices</li>
      </ul>

      <div class="key-point">
        <h4>Human Intuition vs. Mathematical Certainty</h4>
        <p>We can't "see" the 4D likelihood surface, but we can <em>prove</em> the algorithm found the maximum: the gradient is zero at the MLE, and the Hessian is negative definite. Maths gives us certainty where visualisation fails.</p>
      </div>

      <h3 style="margin-top: 25px;">Statistics vs. Machine Learning</h3>
      <p>
        <strong>Statistical models</strong> (like GLMs) typically have tens to hundreds of parameters, each carefully chosen to represent a meaningful effect.
        A logistic regression predicting disease risk might have 20‚Äì50 predictors, each with a clear interpretation.
      </p>
      <p>
        <strong>Machine learning and AI models</strong> scale to much higher dimensions:
      </p>
      <ul>
        <li>ResNet-50 (image classification): ~25 million parameters (10‚Å∑)</li>
        <li>BERT (language understanding): 340 million parameters (10‚Å∏)</li>
        <li>GPT-2: 1.5 billion parameters (10‚Åπ)</li>
        <li>GPT-3: 175 billion parameters (10¬π¬π)</li>
        <li>GPT-4: ~1.7 trillion parameters estimated (10¬π¬≤)</li>
      </ul>
      <p style="margin-top: 15px;">
        At these scales, exact methods like Newton-Raphson become impractical (inverting a billion√óbillion matrix is impossible).
        Instead, AI training uses <strong>stochastic gradient descent (SGD)</strong> and variants like Adam ‚Äî computing approximate gradients
        on small batches of data and taking many small steps. The core principle is the same: follow the gradient toward better parameters.
      </p>
    </div>

    <footer>
      <a href="../index.html">‚Üê Back to Tutorials</a>
    </footer>
  </div>

  <script>
    // ========================================
    // 4D Likelihood Visualization
    // ========================================

    const progressCanvas = document.getElementById('progress-canvas');
    const progressCtx = progressCanvas.getContext('2d');

    // High DPI support
    function setupCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const rect = progressCanvas.getBoundingClientRect();
      progressCanvas.width = rect.width * dpr;
      progressCanvas.height = rect.height * dpr;
      progressCtx.scale(dpr, dpr);
      progressCanvas.style.width = rect.width + 'px';
      progressCanvas.style.height = rect.height + 'px';
    }

    // State
    let currentMode = 'manual';
    let currentAlgorithm = 'analytic';
    let currentProjection = 'b0'; // Which parameter is fixed
    let currentB0 = 5;
    let currentB1 = 0;
    let currentB2 = 0;
    let currentB3 = 0;
    let iteration = 0;
    let isRunning = false;
    let animationId = null;
    let history = [];

    // True parameters
    const trueB0 = 5;
    const trueB1 = 2;
    const trueB2 = -1.5;
    const trueB3 = 1;
    const n = 50;
    let data = [];

    // MLE estimates
    let mleB0 = 0, mleB1 = 0, mleB2 = 0, mleB3 = 0;

    // Parameter ranges
    const b0Range = { min: -5, max: 15 };
    const b1Range = { min: -4, max: 6 };
    const b2Range = { min: -5, max: 3 };
    const b3Range = { min: -3, max: 4 };

    // Generate sample data
    function generateData() {
      data = [];
      for (let i = 0; i < n; i++) {
        const x1 = Math.random() * 10 - 5;
        const x2 = Math.random() * 10 - 5;
        const x3 = Math.random() * 10 - 5;
        const noise = (Math.random() - 0.5) * 10;
        const y = trueB0 + trueB1 * x1 + trueB2 * x2 + trueB3 * x3 + noise;
        data.push({ x1, x2, x3, y });
      }

      computeMLE();
    }

    // Compute OLS estimates using normal equations with 4x4 matrix
    function computeMLE() {
      // Œ≤ = (X'X)^(-1) X'y
      let X = data.map(d => [1, d.x1, d.x2, d.x3]);
      let Y = data.map(d => d.y);

      // X'X (4x4)
      let XtX = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]];
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < 4; j++) {
          for (let k = 0; k < 4; k++) {
            XtX[j][k] += X[i][j] * X[i][k];
          }
        }
      }

      // X'y (4x1)
      let XtY = [0, 0, 0, 0];
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < 4; j++) {
          XtY[j] += X[i][j] * Y[i];
        }
      }

      // Invert 4x4 matrix
      const inv = invert4x4(XtX);

      // Œ≤ = inv(X'X) * X'y
      mleB0 = inv[0][0]*XtY[0] + inv[0][1]*XtY[1] + inv[0][2]*XtY[2] + inv[0][3]*XtY[3];
      mleB1 = inv[1][0]*XtY[0] + inv[1][1]*XtY[1] + inv[1][2]*XtY[2] + inv[1][3]*XtY[3];
      mleB2 = inv[2][0]*XtY[0] + inv[2][1]*XtY[1] + inv[2][2]*XtY[2] + inv[2][3]*XtY[3];
      mleB3 = inv[3][0]*XtY[0] + inv[3][1]*XtY[1] + inv[3][2]*XtY[2] + inv[3][3]*XtY[3];
    }

    // 4x4 matrix inversion using Gaussian elimination
    function invert4x4(m) {
      // Create augmented matrix [m | I]
      const aug = m.map((row, i) => [...row, ...([0,0,0,0].map((_, j) => i === j ? 1 : 0))]);

      // Forward elimination
      for (let col = 0; col < 4; col++) {
        // Find pivot
        let maxRow = col;
        for (let row = col + 1; row < 4; row++) {
          if (Math.abs(aug[row][col]) > Math.abs(aug[maxRow][col])) {
            maxRow = row;
          }
        }
        [aug[col], aug[maxRow]] = [aug[maxRow], aug[col]];

        // Scale pivot row
        const pivot = aug[col][col];
        for (let j = 0; j < 8; j++) {
          aug[col][j] /= pivot;
        }

        // Eliminate column
        for (let row = 0; row < 4; row++) {
          if (row !== col) {
            const factor = aug[row][col];
            for (let j = 0; j < 8; j++) {
              aug[row][j] -= factor * aug[col][j];
            }
          }
        }
      }

      // Extract inverse
      return aug.map(row => row.slice(4));
    }

    // Log-likelihood
    function logLikelihood(b0, b1, b2, b3) {
      let ss = 0;
      for (const d of data) {
        const pred = b0 + b1 * d.x1 + b2 * d.x2 + b3 * d.x3;
        const resid = d.y - pred;
        ss += resid * resid;
      }
      const sigma2 = 25;
      return -n/2 * Math.log(2 * Math.PI * sigma2) - ss / (2 * sigma2);
    }

    // Gradient (4 components)
    function gradient(b0, b1, b2, b3) {
      let g0 = 0, g1 = 0, g2 = 0, g3 = 0;
      const sigma2 = 25;
      for (const d of data) {
        const resid = d.y - (b0 + b1 * d.x1 + b2 * d.x2 + b3 * d.x3);
        g0 += resid;
        g1 += resid * d.x1;
        g2 += resid * d.x2;
        g3 += resid * d.x3;
      }
      return [g0 / sigma2, g1 / sigma2, g2 / sigma2, g3 / sigma2];
    }

    // Hessian (4x4 matrix)
    function hessian() {
      const sigma2 = 25;
      let H = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]];
      for (const d of data) {
        const x = [1, d.x1, d.x2, d.x3];
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            H[i][j] -= x[i] * x[j] / sigma2;
          }
        }
      }
      return H;
    }

    // Distance from MLE
    function distanceFromMLE(b0, b1, b2, b3) {
      return Math.sqrt(
        (b0 - mleB0) ** 2 +
        (b1 - mleB1) ** 2 +
        (b2 - mleB2) ** 2 +
        (b3 - mleB3) ** 2
      );
    }

    // Draw 3D projection using Plotly
    let plotlyInitialized = false;

    function drawProjection() {
      const plotlyDiv = document.getElementById('plotly-projection');

      // Compute 3D likelihood volume for the projection
      const gridSize = 12;
      let xVals = [], yVals = [], zVals = [];
      let xRange, yRange, zRange;
      let xLabel, yLabel, zLabel;
      let fixedLabel, fixedValue;

      // Determine which axes based on projection
      switch (currentProjection) {
        case 'b0':
          xRange = b1Range; yRange = b2Range; zRange = b3Range;
          xLabel = 'Œ≤‚ÇÅ'; yLabel = 'Œ≤‚ÇÇ'; zLabel = 'Œ≤‚ÇÉ';
          fixedLabel = 'Œ≤‚ÇÄ'; fixedValue = currentB0;
          break;
        case 'b1':
          xRange = b0Range; yRange = b2Range; zRange = b3Range;
          xLabel = 'Œ≤‚ÇÄ'; yLabel = 'Œ≤‚ÇÇ'; zLabel = 'Œ≤‚ÇÉ';
          fixedLabel = 'Œ≤‚ÇÅ'; fixedValue = currentB1;
          break;
        case 'b2':
          xRange = b0Range; yRange = b1Range; zRange = b3Range;
          xLabel = 'Œ≤‚ÇÄ'; yLabel = 'Œ≤‚ÇÅ'; zLabel = 'Œ≤‚ÇÉ';
          fixedLabel = 'Œ≤‚ÇÇ'; fixedValue = currentB2;
          break;
        case 'b3':
          xRange = b0Range; yRange = b1Range; zRange = b2Range;
          xLabel = 'Œ≤‚ÇÄ'; yLabel = 'Œ≤‚ÇÅ'; zLabel = 'Œ≤‚ÇÇ';
          fixedLabel = 'Œ≤‚ÇÉ'; fixedValue = currentB3;
          break;
      }

      for (let i = 0; i <= gridSize; i++) {
        xVals.push(xRange.min + (xRange.max - xRange.min) * i / gridSize);
        yVals.push(yRange.min + (yRange.max - yRange.min) * i / gridSize);
        zVals.push(zRange.min + (zRange.max - zRange.min) * i / gridSize);
      }

      // Compute likelihood at each point
      const xFlat = [], yFlat = [], zFlat = [], llFlat = [];
      let minLL = Infinity, maxLL = -Infinity;

      for (let i = 0; i <= gridSize; i++) {
        for (let j = 0; j <= gridSize; j++) {
          for (let k = 0; k <= gridSize; k++) {
            let ll;
            switch (currentProjection) {
              case 'b0':
                ll = logLikelihood(currentB0, xVals[i], yVals[j], zVals[k]);
                break;
              case 'b1':
                ll = logLikelihood(xVals[i], currentB1, yVals[j], zVals[k]);
                break;
              case 'b2':
                ll = logLikelihood(xVals[i], yVals[j], currentB2, zVals[k]);
                break;
              case 'b3':
                ll = logLikelihood(xVals[i], yVals[j], zVals[k], currentB3);
                break;
            }

            xFlat.push(xVals[i]);
            yFlat.push(yVals[j]);
            zFlat.push(zVals[k]);
            llFlat.push(ll);

            if (isFinite(ll)) {
              minLL = Math.min(minLL, ll);
              maxLL = Math.max(maxLL, ll);
            }
          }
        }
      }

      // Isosurface
      const isoTrace = {
        type: 'isosurface',
        x: xFlat,
        y: yFlat,
        z: zFlat,
        value: llFlat,
        isomin: minLL + (maxLL - minLL) * 0.6,
        isomax: maxLL,
        surface: { count: 4 },
        colorscale: [
          [0, 'rgb(100, 150, 255)'],
          [0.3, 'rgb(255, 255, 150)'],
          [0.6, 'rgb(255, 150, 50)'],
          [1, 'rgb(200, 0, 0)']
        ],
        opacity: 0.3,
        caps: { x: { show: false }, y: { show: false }, z: { show: false } },
        showscale: false
      };

      // MLE point (projected)
      let mleX, mleY, mleZ;
      switch (currentProjection) {
        case 'b0': mleX = mleB1; mleY = mleB2; mleZ = mleB3; break;
        case 'b1': mleX = mleB0; mleY = mleB2; mleZ = mleB3; break;
        case 'b2': mleX = mleB0; mleY = mleB1; mleZ = mleB3; break;
        case 'b3': mleX = mleB0; mleY = mleB1; mleZ = mleB2; break;
      }

      const mleTrace = {
        type: 'scatter3d',
        mode: 'markers+text',
        x: [mleX],
        y: [mleY],
        z: [mleZ],
        marker: { size: 10, color: '#27ae60', symbol: 'diamond' },
        text: ['MLE'],
        textposition: 'top center',
        textfont: { color: '#27ae60', size: 11 },
        name: 'MLE'
      };

      // Current position (projected)
      let curX, curY, curZ;
      switch (currentProjection) {
        case 'b0': curX = currentB1; curY = currentB2; curZ = currentB3; break;
        case 'b1': curX = currentB0; curY = currentB2; curZ = currentB3; break;
        case 'b2': curX = currentB0; curY = currentB1; curZ = currentB3; break;
        case 'b3': curX = currentB0; curY = currentB1; curZ = currentB2; break;
      }

      const currentTrace = {
        type: 'scatter3d',
        mode: 'markers',
        x: [curX],
        y: [curY],
        z: [curZ],
        marker: { size: 8, color: '#e74c3c' },
        name: 'Current'
      };

      const traces = [isoTrace, mleTrace, currentTrace];

      // Path through space
      if (history.length > 1) {
        let pathX = [], pathY = [], pathZ = [];
        for (const h of history) {
          switch (currentProjection) {
            case 'b0': pathX.push(h.b1); pathY.push(h.b2); pathZ.push(h.b3); break;
            case 'b1': pathX.push(h.b0); pathY.push(h.b2); pathZ.push(h.b3); break;
            case 'b2': pathX.push(h.b0); pathY.push(h.b1); pathZ.push(h.b3); break;
            case 'b3': pathX.push(h.b0); pathY.push(h.b1); pathZ.push(h.b2); break;
          }
        }

        traces.push({
          type: 'scatter3d',
          mode: 'lines+markers',
          x: pathX,
          y: pathY,
          z: pathZ,
          line: { color: '#e74c3c', width: 4 },
          marker: { size: 3, color: '#e74c3c' },
          name: 'Path'
        });
      }

      const layout = {
        title: {
          text: `3D Projection (${fixedLabel} = ${fixedValue.toFixed(2)} fixed)`,
          font: { size: 13 }
        },
        scene: {
          xaxis: { title: xLabel, titlefont: { size: 10 } },
          yaxis: { title: yLabel, titlefont: { size: 10 } },
          zaxis: { title: zLabel, titlefont: { size: 10 } },
          camera: { eye: { x: 1.5, y: 1.5, z: 1.2 } }
        },
        margin: { l: 0, r: 0, t: 40, b: 0 },
        showlegend: false
      };

      const config = { responsive: true, displayModeBar: false };

      if (!plotlyInitialized) {
        Plotly.newPlot(plotlyDiv, traces, layout, config);
        plotlyInitialized = true;
      } else {
        Plotly.react(plotlyDiv, traces, layout, config);
      }
    }

    // Draw progress chart (distance from MLE over iterations)
    function drawProgress() {
      const rect = progressCanvas.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;

      progressCtx.clearRect(0, 0, width, height);

      const margin = { top: 30, right: 20, bottom: 40, left: 50 };
      const plotWidth = width - margin.left - margin.right;
      const plotHeight = height - margin.top - margin.bottom;

      // Background
      progressCtx.fillStyle = '#f8f9fa';
      progressCtx.fillRect(margin.left, margin.top, plotWidth, plotHeight);

      // Compute distances for history
      const distances = history.map(h => distanceFromMLE(h.b0, h.b1, h.b2, h.b3));

      if (distances.length === 0) {
        progressCtx.fillStyle = '#999';
        progressCtx.font = '12px -apple-system, sans-serif';
        progressCtx.textAlign = 'center';
        progressCtx.fillText('Start algorithm to see convergence', width / 2, height / 2);
        return;
      }

      const maxDist = Math.max(...distances, 1);
      const maxIter = Math.max(distances.length - 1, 10);

      // Scale functions
      const xScale = (i) => margin.left + (i / maxIter) * plotWidth;
      const yScale = (d) => margin.top + plotHeight - (d / maxDist) * plotHeight;

      // Grid lines
      progressCtx.strokeStyle = '#ddd';
      progressCtx.lineWidth = 1;
      for (let i = 0; i <= 4; i++) {
        const y = margin.top + (i / 4) * plotHeight;
        progressCtx.beginPath();
        progressCtx.moveTo(margin.left, y);
        progressCtx.lineTo(margin.left + plotWidth, y);
        progressCtx.stroke();
      }

      // Draw path
      progressCtx.strokeStyle = '#e74c3c';
      progressCtx.lineWidth = 2;
      progressCtx.beginPath();
      for (let i = 0; i < distances.length; i++) {
        const x = xScale(i);
        const y = yScale(distances[i]);
        if (i === 0) {
          progressCtx.moveTo(x, y);
        } else {
          progressCtx.lineTo(x, y);
        }
      }
      progressCtx.stroke();

      // Draw points
      progressCtx.fillStyle = '#e74c3c';
      for (let i = 0; i < distances.length; i++) {
        const x = xScale(i);
        const y = yScale(distances[i]);
        progressCtx.beginPath();
        progressCtx.arc(x, y, 4, 0, Math.PI * 2);
        progressCtx.fill();
      }

      // Target line (distance = 0)
      progressCtx.strokeStyle = '#27ae60';
      progressCtx.lineWidth = 2;
      progressCtx.setLineDash([5, 5]);
      progressCtx.beginPath();
      progressCtx.moveTo(margin.left, yScale(0));
      progressCtx.lineTo(margin.left + plotWidth, yScale(0));
      progressCtx.stroke();
      progressCtx.setLineDash([]);

      // Axes
      progressCtx.strokeStyle = '#333';
      progressCtx.lineWidth = 2;

      // X axis
      progressCtx.beginPath();
      progressCtx.moveTo(margin.left, margin.top + plotHeight);
      progressCtx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
      progressCtx.stroke();

      // Y axis
      progressCtx.beginPath();
      progressCtx.moveTo(margin.left, margin.top);
      progressCtx.lineTo(margin.left, margin.top + plotHeight);
      progressCtx.stroke();

      // Labels
      progressCtx.fillStyle = '#333';
      progressCtx.font = '11px -apple-system, sans-serif';
      progressCtx.textAlign = 'center';
      progressCtx.fillText('Iteration', margin.left + plotWidth / 2, height - 8);

      progressCtx.save();
      progressCtx.translate(12, margin.top + plotHeight / 2);
      progressCtx.rotate(-Math.PI / 2);
      progressCtx.fillText('Distance from MLE', 0, 0);
      progressCtx.restore();

      // Title
      progressCtx.font = 'bold 12px -apple-system, sans-serif';
      progressCtx.fillText('Convergence in 4D Space', margin.left + plotWidth / 2, 15);
    }

    // Update stats display
    function updateStats() {
      document.getElementById('current-b0').textContent = currentB0.toFixed(2);
      document.getElementById('current-b1').textContent = currentB1.toFixed(2);
      document.getElementById('current-b2').textContent = currentB2.toFixed(2);
      document.getElementById('current-b3').textContent = currentB3.toFixed(2);
      document.getElementById('current-ll').textContent = logLikelihood(currentB0, currentB1, currentB2, currentB3).toFixed(2);
      document.getElementById('iteration-count').textContent = iteration;
    }

    // Algorithm step
    function algorithmStep() {
      switch (currentAlgorithm) {
        case 'analytic':
          currentB0 = mleB0;
          currentB1 = mleB1;
          currentB2 = mleB2;
          currentB3 = mleB3;
          iteration = 1;
          history.push({ b0: currentB0, b1: currentB1, b2: currentB2, b3: currentB3 });
          isRunning = false;
          break;

        case 'newton':
          const gN = gradient(currentB0, currentB1, currentB2, currentB3);
          const H = hessian();
          const Hinv = invert4x4(H);

          // Œ≤_new = Œ≤ - H^(-1) * g
          const delta = [];
          for (let i = 0; i < 4; i++) {
            let d = 0;
            for (let j = 0; j < 4; j++) {
              d -= Hinv[i][j] * gN[j];
            }
            delta.push(d);
          }

          currentB0 += delta[0];
          currentB1 += delta[1];
          currentB2 += delta[2];
          currentB3 += delta[3];
          iteration++;
          history.push({ b0: currentB0, b1: currentB1, b2: currentB2, b3: currentB3 });

          const deltaMag = Math.sqrt(delta.reduce((s, d) => s + d*d, 0));
          if (deltaMag < 0.001 || iteration > 20) {
            isRunning = false;
          }
          break;

        case 'gradient':
          const g = gradient(currentB0, currentB1, currentB2, currentB3);

          // Adaptive learning rates
          const lr0 = 0.08;
          const lr1 = 0.015;
          const lr2 = 0.015;
          const lr3 = 0.015;

          currentB0 += lr0 * g[0];
          currentB1 += lr1 * g[1];
          currentB2 += lr2 * g[2];
          currentB3 += lr3 * g[3];
          iteration++;
          history.push({ b0: currentB0, b1: currentB1, b2: currentB2, b3: currentB3 });

          const gradMag = Math.sqrt(g.reduce((s, gi) => s + gi*gi, 0));
          if (gradMag < 0.01 || iteration > 400) {
            isRunning = false;
          }
          break;
      }

      updateSliders();
      updateStats();
      drawProjection();
      drawProgress();
    }

    // Animation loop
    function animate() {
      if (!isRunning) return;

      algorithmStep();

      if (isRunning) {
        animationId = setTimeout(animate, 150);
      }
    }

    // Reset
    function reset() {
      isRunning = false;
      if (animationId) clearTimeout(animationId);

      // Random starting point
      currentB0 = b0Range.min + Math.random() * (b0Range.max - b0Range.min);
      currentB1 = b1Range.min + Math.random() * (b1Range.max - b1Range.min);
      currentB2 = b2Range.min + Math.random() * (b2Range.max - b2Range.min);
      currentB3 = b3Range.min + Math.random() * (b3Range.max - b3Range.min);

      iteration = 0;
      history = [{ b0: currentB0, b1: currentB1, b2: currentB2, b3: currentB3 }];
      document.getElementById('start-btn').textContent = 'Start';

      updateSliders();
      updateStats();
      drawProjection();
      drawProgress();
    }

    // Mode switching
    function setMode(mode) {
      currentMode = mode;

      document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === mode);
      });

      document.getElementById('manual-controls').classList.toggle('hidden', mode !== 'manual');
      document.getElementById('algorithm-controls').classList.toggle('hidden', mode !== 'algorithm');
      document.getElementById('algorithm-info').classList.toggle('hidden', mode !== 'algorithm');

      reset();

      if (mode === 'manual') {
        currentB0 = 5;
        currentB1 = 0;
        currentB2 = 0;
        currentB3 = 0;
        updateSliders();
        updateFromSliders();
      }
    }

    // Update sliders to match current values
    function updateSliders() {
      document.getElementById('b0-slider').value = currentB0;
      document.getElementById('b0-value').textContent = currentB0.toFixed(1);

      document.getElementById('b1-slider').value = currentB1;
      document.getElementById('b1-value').textContent = currentB1.toFixed(2);

      document.getElementById('b2-slider').value = currentB2;
      document.getElementById('b2-value').textContent = currentB2.toFixed(2);

      document.getElementById('b3-slider').value = currentB3;
      document.getElementById('b3-value').textContent = currentB3.toFixed(2);
    }

    // Update from sliders
    function updateFromSliders() {
      currentB0 = parseFloat(document.getElementById('b0-slider').value);
      currentB1 = parseFloat(document.getElementById('b1-slider').value);
      currentB2 = parseFloat(document.getElementById('b2-slider').value);
      currentB3 = parseFloat(document.getElementById('b3-slider').value);

      document.getElementById('b0-value').textContent = currentB0.toFixed(1);
      document.getElementById('b1-value').textContent = currentB1.toFixed(2);
      document.getElementById('b2-value').textContent = currentB2.toFixed(2);
      document.getElementById('b3-value').textContent = currentB3.toFixed(2);

      updateStats();
      drawProjection();
    }

    // Event listeners
    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.addEventListener('click', () => setMode(btn.dataset.mode));
    });

    ['b0', 'b1', 'b2', 'b3'].forEach(param => {
      document.getElementById(`${param}-slider`).addEventListener('input', updateFromSliders);
    });

    // Projection selector
    document.querySelectorAll('input[name="projection"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        currentProjection = e.target.value;
        plotlyInitialized = false; // Force redraw
        drawProjection();
      });
    });

    document.getElementById('algorithm-select').addEventListener('change', (e) => {
      currentAlgorithm = e.target.value;
      updateAlgorithmInfo();
      reset();
    });

    document.getElementById('start-btn').addEventListener('click', () => {
      if (isRunning) {
        isRunning = false;
        document.getElementById('start-btn').textContent = 'Continue';
      } else {
        isRunning = true;
        document.getElementById('start-btn').textContent = 'Pause';
        animate();
      }
    });

    document.getElementById('reset-btn').addEventListener('click', reset);

    // Update algorithm info
    function updateAlgorithmInfo() {
      const info = {
        analytic: {
          name: 'Analytic Solution (OLS)',
          desc: 'Computes the exact MLE using 4√ó4 matrix inversion: Œ≤ = (X\'X)‚Åª¬πX\'y. Same formula as 2D ‚Äî just bigger matrices!'
        },
        newton: {
          name: 'Newton-Raphson',
          desc: 'Uses a 4√ó4 Hessian matrix: Œ≤_new = Œ≤ - H‚Åª¬π‚àá‚Ñì. Still converges in 1-2 steps regardless of dimensionality.'
        },
        gradient: {
          name: 'Gradient Descent',
          desc: 'Follows the 4-dimensional gradient vector. Each step moves in all 4 directions simultaneously.'
        }
      };

      document.getElementById('algo-name').textContent = info[currentAlgorithm].name;
      document.getElementById('algo-desc').textContent = info[currentAlgorithm].desc;
    }

    // Set canvas size
    progressCanvas.style.width = '100%';
    progressCanvas.style.height = '340px';

    // Initialize
    window.addEventListener('resize', () => {
      setupCanvas();
      drawProgress();
    });

    setupCanvas();
    generateData();
    updateSliders();
    updateAlgorithmInfo();
    updateFromSliders();
    drawProgress();
  </script>
</body>
</html>
