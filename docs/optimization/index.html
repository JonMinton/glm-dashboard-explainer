<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Optimization Visualized: 1D Likelihood</title>

  <!-- KaTeX for math -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      color: #2c3e50;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
      overflow: hidden;
    }

    header {
      background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
      color: white;
      padding: 30px;
    }

    header h1 {
      font-size: 1.8em;
      margin-bottom: 10px;
    }

    header p {
      opacity: 0.9;
      font-size: 1.1em;
    }

    .back-link {
      display: inline-block;
      color: rgba(255,255,255,0.8);
      text-decoration: none;
      margin-bottom: 15px;
      font-size: 0.9em;
    }

    .back-link:hover {
      color: white;
    }

    main {
      padding: 30px;
    }

    .intro {
      background: #f8f9fa;
      border-left: 4px solid #667eea;
      padding: 20px;
      margin-bottom: 30px;
      border-radius: 0 8px 8px 0;
    }

    .intro h2 {
      color: #667eea;
      margin-bottom: 10px;
    }

    /* Visualization container */
    .viz-container {
      background: #fafafa;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 30px;
    }

    .viz-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 15px;
    }

    .viz-title {
      font-size: 1.2em;
      font-weight: 600;
      color: #2c3e50;
    }

    /* Dual canvas layout */
    .canvas-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 15px;
    }

    @media (max-width: 700px) {
      .canvas-grid {
        grid-template-columns: 1fr;
      }
    }

    .canvas-panel {
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 15px;
    }

    .canvas-panel h4 {
      margin: 0 0 10px 0;
      font-size: 0.95em;
      color: #666;
      text-align: center;
    }

    /* Canvas styling */
    #data-canvas, #likelihood-canvas {
      width: 100%;
      height: 280px;
      background: white;
      border: 1px solid #eee;
      border-radius: 4px;
    }

    /* Mode toggle */
    .mode-toggle {
      display: flex;
      background: #e0e0e0;
      border-radius: 8px;
      padding: 4px;
      margin-bottom: 20px;
    }

    .mode-btn {
      flex: 1;
      padding: 10px 20px;
      border: none;
      background: transparent;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      color: #666;
      transition: all 0.2s;
    }

    .mode-btn.active {
      background: white;
      color: #667eea;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .mode-btn:hover:not(.active) {
      color: #2c3e50;
    }

    /* Manual slider */
    .manual-controls {
      background: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: 8px;
      padding: 20px;
      margin-top: 15px;
    }

    .manual-controls.hidden {
      display: none;
    }

    .manual-controls h4 {
      color: #856404;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .manual-controls h4::before {
      content: 'ðŸ‘†';
    }

    .slider-container {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-top: 10px;
    }

    .slider-container label {
      font-weight: 500;
      color: #666;
      min-width: 80px;
    }

    .slider-container input[type="range"] {
      flex: 1;
      height: 8px;
      border-radius: 4px;
      background: #ddd;
      outline: none;
      -webkit-appearance: none;
    }

    .slider-container input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #e74c3c;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .slider-value {
      font-family: 'SF Mono', Monaco, monospace;
      font-weight: 600;
      min-width: 60px;
      text-align: right;
    }

    .manual-hint {
      font-size: 0.9em;
      color: #856404;
      margin-top: 10px;
      font-style: italic;
    }

    .attempts-counter {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid #ffc107;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .attempts-counter span {
      color: #856404;
    }

    .attempts-counter .count {
      font-weight: 600;
      font-size: 1.2em;
    }

    /* Controls */
    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 20px;
      align-items: center;
    }

    .controls.hidden {
      display: none;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .control-group label {
      font-size: 0.9em;
      color: #666;
      font-weight: 500;
    }

    select, button {
      padding: 8px 16px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 0.9em;
      cursor: pointer;
      transition: all 0.2s;
    }

    select:hover, button:hover {
      border-color: #667eea;
    }

    button {
      background: #667eea;
      color: white;
      border: none;
    }

    button:hover {
      background: #5a6fd6;
    }

    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    button.secondary {
      background: #95a5a6;
    }

    button.secondary:hover {
      background: #7f8c8d;
    }

    /* Canvas cursor */
    #likelihood-canvas.manual-mode {
      cursor: crosshair;
    }

    /* Stats display */
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid #eee;
    }

    .stat-box {
      background: white;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
      text-align: center;
    }

    .stat-label {
      font-size: 0.8em;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .stat-value {
      font-size: 1.4em;
      font-weight: 600;
      color: #2c3e50;
      font-family: 'SF Mono', Monaco, monospace;
    }

    .stat-value.highlight {
      color: #667eea;
    }

    /* Explanation sections */
    .explanation {
      margin-top: 30px;
    }

    .explanation h3 {
      color: #2c3e50;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid #667eea;
    }

    .explanation p {
      margin-bottom: 15px;
      color: #555;
    }

    .math-block {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
      overflow-x: auto;
      text-align: center;
    }

    /* Algorithm legend */
    .algorithm-info {
      background: #e8f4f8;
      padding: 15px 20px;
      border-radius: 8px;
      margin-top: 15px;
    }

    .algorithm-info h4 {
      color: #2980b9;
      margin-bottom: 8px;
    }

    .algorithm-info p {
      font-size: 0.95em;
      color: #555;
      margin: 0;
    }

    /* Navigation */
    .nav-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 40px;
      padding-top: 20px;
      border-top: 1px solid #eee;
    }

    .nav-btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 12px 24px;
      background: #667eea;
      color: white;
      text-decoration: none;
      border-radius: 8px;
      font-weight: 500;
      transition: background 0.2s;
    }

    .nav-btn:hover {
      background: #5a6fd6;
    }

    .nav-btn.secondary {
      background: #95a5a6;
    }

    .nav-btn.secondary:hover {
      background: #7f8c8d;
    }

    footer {
      text-align: center;
      padding: 20px;
      background: #f8f9fa;
      color: #888;
      font-size: 0.9em;
    }

    footer a {
      color: #667eea;
    }

    /* Responsive */
    @media (max-width: 600px) {
      header h1 {
        font-size: 1.4em;
      }

      .controls {
        flex-direction: column;
        align-items: stretch;
      }

      .control-group {
        justify-content: space-between;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <a href="../index.html" class="back-link">&larr; Back to Tutorials</a>
      <h1>Optimization Visualized</h1>
      <p>See how algorithms find the maximum likelihood estimate</p>
    </header>

    <main>
      <section class="intro">
        <h2>1D: The Simplest Case</h2>
        <p>
          Before tackling real models with many parameters, let's build intuition with the
          simplest possible case: estimating a single parameter &mdash; the mean of some data.
        </p>
        <p>
          The <strong>log-likelihood curve</strong> below shows how "good" each possible
          parameter value is. Our goal is to find the peak &mdash; the Maximum Likelihood Estimate (MLE).
        </p>
      </section>

      <section class="viz-container">
        <div class="viz-header">
          <span class="viz-title">Log-Likelihood Surface</span>
          <div class="control-group">
            <label for="distribution-select">Distribution:</label>
            <select id="distribution-select">
              <option value="gaussian" selected>Gaussian (continuous)</option>
              <option value="poisson">Poisson (counts)</option>
              <option value="binomial">Binomial (proportions)</option>
            </select>
          </div>
        </div>

        <!-- Mode toggle -->
        <div class="mode-toggle">
          <button class="mode-btn active" data-mode="manual">Try It Yourself</button>
          <button class="mode-btn" data-mode="algorithm">Watch Algorithm</button>
        </div>

        <!-- Dual canvas view -->
        <div class="canvas-grid">
          <div class="canvas-panel">
            <h4>Data + Current Fit</h4>
            <canvas id="data-canvas"></canvas>
          </div>
          <div class="canvas-panel">
            <h4>Log-Likelihood Surface</h4>
            <canvas id="likelihood-canvas"></canvas>
          </div>
        </div>

        <!-- Manual mode controls -->
        <div class="manual-controls" id="manual-controls">
          <h4>Find the Peak!</h4>
          <p>Drag the slider or click on the curve to set your estimate. Can you find the maximum?</p>

          <div class="slider-container">
            <label id="param-label">Mean (Î¼):</label>
            <input type="range" id="param-slider" min="0" max="100" value="50" step="0.1">
            <span class="slider-value" id="slider-value">150.0</span>
          </div>

          <p class="manual-hint">Tip: Watch the log-likelihood value &mdash; higher is better!</p>

          <div class="attempts-counter">
            <span>Adjustments made:</span>
            <span class="count" id="attempt-count">0</span>
          </div>
        </div>

        <!-- Algorithm mode controls -->
        <div class="controls hidden" id="algorithm-controls">
          <div class="control-group">
            <label for="algorithm-select">Algorithm:</label>
            <select id="algorithm-select">
              <option value="analytic">Analytic (one-shot)</option>
              <option value="newton">Newton-Raphson</option>
              <option value="gradient">Gradient Descent</option>
            </select>
          </div>

          <button id="start-btn">Start</button>
          <button id="step-btn" class="secondary">Step</button>
          <button id="reset-btn" class="secondary">Reset</button>
        </div>

        <div class="stats">
          <div class="stat-box">
            <div class="stat-label">Current Estimate</div>
            <div class="stat-value" id="current-estimate">--</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Log-Likelihood</div>
            <div class="stat-value" id="current-ll">--</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Iteration</div>
            <div class="stat-value highlight" id="iteration-count">0</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">True MLE</div>
            <div class="stat-value" id="true-mle">--</div>
          </div>
        </div>

        <div class="algorithm-info" id="algorithm-info">
          <h4>Analytic Solution</h4>
          <p>For the Gaussian mean, we can solve directly: the MLE is simply the sample mean $\bar{y}$. No iteration needed!</p>
        </div>
      </section>

      <section class="explanation">
        <h3>What You're Seeing</h3>
        <p>
          The curve shows the <strong>log-likelihood function</strong> $\ell(\theta)$ for different
          values of the parameter $\theta$. Higher values mean the parameter explains the data better.
        </p>

        <div class="math-block">
          $$\ell(\theta) = \sum_{i=1}^{n} \log f(y_i \mid \theta)$$
        </div>

        <p>
          The <strong style="color: #e74c3c;">red dot</strong> shows the current estimate.
          Watch how different algorithms navigate to the peak:
        </p>

        <ul style="margin-left: 20px; margin-bottom: 20px;">
          <li><strong>Analytic:</strong> Jumps directly to the solution (when a formula exists)</li>
          <li><strong>Newton-Raphson:</strong> Uses curvature information for fast convergence</li>
          <li><strong>Gradient Descent:</strong> Follows the slope uphill, step by step</li>
        </ul>

        <h3>Why This Matters</h3>
        <p>
          In 1D, finding the maximum is trivial &mdash; you can see it! But real models have
          many parameters, creating surfaces we can't visualize. Understanding how algorithms
          work in 1D builds intuition for what happens in higher dimensions.
        </p>
      </section>

      <nav class="nav-buttons">
        <a href="../index.html" class="nav-btn secondary">&larr; Tutorials</a>
        <a href="2d.html" class="nav-btn">2D Likelihood &rarr;</a>
      </nav>
    </main>

    <footer>
      Part of the <a href="https://jonminton.github.io/JonStats/">JonStats</a> teaching materials.
    </footer>
  </div>

  <script src="../js/feedback.js"></script>

  <script>
    // Initialize KaTeX
    document.addEventListener('DOMContentLoaded', function() {
      if (typeof renderMathInElement !== 'undefined') {
        renderMathInElement(document.body, {
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false}
          ]
        });
      }
    });

    // ========================================
    // Likelihood Visualization
    // ========================================

    const canvas = document.getElementById('likelihood-canvas');
    const ctx = canvas.getContext('2d');
    const dataCanvas = document.getElementById('data-canvas');
    const dataCtx = dataCanvas.getContext('2d');

    // High DPI support
    function setupCanvas() {
      // Setup likelihood canvas
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.scale(dpr, dpr);
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';

      // Setup data canvas
      const dataRect = dataCanvas.getBoundingClientRect();
      dataCanvas.width = dataRect.width * dpr;
      dataCanvas.height = dataRect.height * dpr;
      dataCtx.scale(dpr, dpr);
      dataCanvas.style.width = dataRect.width + 'px';
      dataCanvas.style.height = dataRect.height + 'px';
    }

    // State
    let currentDistribution = 'gaussian';
    let currentAlgorithm = 'analytic';
    let currentEstimate = null;
    let iteration = 0;
    let isRunning = false;
    let animationId = null;
    let history = [];
    let currentMode = 'manual'; // 'manual' or 'algorithm'
    let manualAttempts = 0;

    // Sample data (will be generated based on distribution)
    let data = [];
    let trueMLE = 0;
    let paramRange = { min: 0, max: 10 };

    // Canvas layout (stored for click detection)
    let canvasLayout = {
      margin: { top: 30, right: 30, bottom: 50, left: 70 },
      plotWidth: 0,
      plotHeight: 0
    };

    // Generate sample data
    function generateData() {
      data = [];
      const n = 50;

      switch (currentDistribution) {
        case 'gaussian':
          // Generate from N(150, 20) - like heart rate
          const trueMean = 150;
          for (let i = 0; i < n; i++) {
            // Box-Muller transform
            const u1 = Math.random();
            const u2 = Math.random();
            const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            data.push(trueMean + 20 * z);
          }
          trueMLE = data.reduce((a, b) => a + b, 0) / n;
          paramRange = { min: 120, max: 180 };
          break;

        case 'poisson':
          // Generate from Poisson(5)
          const trueLambda = 5;
          for (let i = 0; i < n; i++) {
            let L = Math.exp(-trueLambda);
            let k = 0;
            let p = 1;
            do {
              k++;
              p *= Math.random();
            } while (p > L);
            data.push(k - 1);
          }
          trueMLE = data.reduce((a, b) => a + b, 0) / n;
          paramRange = { min: 1, max: 10 };
          break;

        case 'binomial':
          // Generate from Binomial(10, 0.3) - show proportion
          const trueP = 0.3;
          const trials = 10;
          for (let i = 0; i < n; i++) {
            let successes = 0;
            for (let j = 0; j < trials; j++) {
              if (Math.random() < trueP) successes++;
            }
            data.push(successes / trials); // Store as proportion
          }
          trueMLE = data.reduce((a, b) => a + b, 0) / n;
          paramRange = { min: 0.05, max: 0.6 };
          break;
      }

      document.getElementById('true-mle').textContent = trueMLE.toFixed(2);
    }

    // Log-likelihood functions
    function logLikelihood(theta) {
      let ll = 0;
      const n = data.length;

      switch (currentDistribution) {
        case 'gaussian':
          // Assuming known variance = 400 (sd = 20)
          const sigma2 = 400;
          for (let i = 0; i < n; i++) {
            ll += -0.5 * Math.log(2 * Math.PI * sigma2) -
                  0.5 * Math.pow(data[i] - theta, 2) / sigma2;
          }
          break;

        case 'poisson':
          if (theta <= 0) return -Infinity;
          for (let i = 0; i < n; i++) {
            const y = data[i];
            ll += y * Math.log(theta) - theta - logFactorial(y);
          }
          break;

        case 'binomial':
          if (theta <= 0 || theta >= 1) return -Infinity;
          for (let i = 0; i < n; i++) {
            const p = data[i]; // proportion
            const trials = 10;
            const successes = Math.round(p * trials);
            ll += successes * Math.log(theta) +
                  (trials - successes) * Math.log(1 - theta);
          }
          break;
      }

      return ll;
    }

    function logFactorial(n) {
      if (n <= 1) return 0;
      let result = 0;
      for (let i = 2; i <= n; i++) {
        result += Math.log(i);
      }
      return result;
    }

    // Gradient (first derivative of log-likelihood)
    function gradient(theta) {
      const h = 0.0001;
      return (logLikelihood(theta + h) - logLikelihood(theta - h)) / (2 * h);
    }

    // Hessian (second derivative)
    function hessian(theta) {
      const h = 0.0001;
      return (logLikelihood(theta + h) - 2 * logLikelihood(theta) + logLikelihood(theta - h)) / (h * h);
    }

    // Draw the data panel (left side)
    function drawData() {
      const rect = dataCanvas.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;

      dataCtx.clearRect(0, 0, width, height);

      const margin = { top: 30, right: 20, bottom: 40, left: 50 };
      const plotWidth = width - margin.left - margin.right;
      const plotHeight = height - margin.top - margin.bottom;

      // Determine y-axis range based on distribution
      let yMin, yMax;
      switch (currentDistribution) {
        case 'gaussian':
          yMin = Math.min(...data) - 10;
          yMax = Math.max(...data) + 10;
          break;
        case 'poisson':
          yMin = 0;
          yMax = Math.max(...data) + 2;
          break;
        case 'binomial':
          yMin = 0;
          yMax = 1;
          break;
      }

      // Scale functions
      const xScale = (i) => margin.left + (i / (data.length - 1)) * plotWidth;
      const yScale = (y) => margin.top + plotHeight - ((y - yMin) / (yMax - yMin)) * plotHeight;

      // Draw axes
      dataCtx.strokeStyle = '#ccc';
      dataCtx.lineWidth = 1;

      // X-axis
      dataCtx.beginPath();
      dataCtx.moveTo(margin.left, margin.top + plotHeight);
      dataCtx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
      dataCtx.stroke();

      // Y-axis
      dataCtx.beginPath();
      dataCtx.moveTo(margin.left, margin.top);
      dataCtx.lineTo(margin.left, margin.top + plotHeight);
      dataCtx.stroke();

      // Y-axis label
      dataCtx.save();
      dataCtx.fillStyle = '#666';
      dataCtx.font = '12px -apple-system, sans-serif';
      dataCtx.translate(12, margin.top + plotHeight / 2);
      dataCtx.rotate(-Math.PI / 2);
      dataCtx.textAlign = 'center';
      dataCtx.fillText(getDataLabel(), 0, 0);
      dataCtx.restore();

      // X-axis label
      dataCtx.fillStyle = '#666';
      dataCtx.font = '12px -apple-system, sans-serif';
      dataCtx.textAlign = 'center';
      dataCtx.fillText('Observation', margin.left + plotWidth / 2, height - 8);

      // Draw the current fitted line/value (BEFORE data points so it's behind)
      if (currentEstimate !== null) {
        const fitY = yScale(currentEstimate);

        // Horizontal line at current estimate
        dataCtx.beginPath();
        dataCtx.strokeStyle = '#e74c3c';
        dataCtx.lineWidth = 2;
        dataCtx.setLineDash([8, 4]);
        dataCtx.moveTo(margin.left, fitY);
        dataCtx.lineTo(margin.left + plotWidth, fitY);
        dataCtx.stroke();
        dataCtx.setLineDash([]);

        // Label
        dataCtx.fillStyle = '#e74c3c';
        dataCtx.font = 'bold 11px -apple-system, sans-serif';
        dataCtx.textAlign = 'right';
        dataCtx.fillText('Î¸ = ' + currentEstimate.toFixed(1), margin.left + plotWidth - 5, fitY - 5);
      }

      // Draw the true MLE line
      const mleY = yScale(trueMLE);
      dataCtx.beginPath();
      dataCtx.strokeStyle = '#27ae60';
      dataCtx.lineWidth = 2;
      dataCtx.setLineDash([4, 4]);
      dataCtx.moveTo(margin.left, mleY);
      dataCtx.lineTo(margin.left + plotWidth, mleY);
      dataCtx.stroke();
      dataCtx.setLineDash([]);

      // MLE label
      dataCtx.fillStyle = '#27ae60';
      dataCtx.font = '11px -apple-system, sans-serif';
      dataCtx.textAlign = 'left';
      dataCtx.fillText('MLE = ' + trueMLE.toFixed(1), margin.left + 5, mleY - 5);

      // Draw data points
      dataCtx.fillStyle = '#667eea';
      for (let i = 0; i < data.length; i++) {
        const x = xScale(i);
        const y = yScale(data[i]);

        dataCtx.beginPath();
        dataCtx.arc(x, y, 4, 0, Math.PI * 2);
        dataCtx.fill();
      }

      // Draw residuals (lines from fit to data) if we have an estimate
      if (currentEstimate !== null) {
        dataCtx.strokeStyle = 'rgba(231, 76, 60, 0.3)';
        dataCtx.lineWidth = 1;
        const fitY = yScale(currentEstimate);

        for (let i = 0; i < data.length; i++) {
          const x = xScale(i);
          const y = yScale(data[i]);

          dataCtx.beginPath();
          dataCtx.moveTo(x, y);
          dataCtx.lineTo(x, fitY);
          dataCtx.stroke();
        }
      }
    }

    function getDataLabel() {
      switch (currentDistribution) {
        case 'gaussian': return 'Value (y)';
        case 'poisson': return 'Count (y)';
        case 'binomial': return 'Proportion (y)';
      }
    }

    // Draw the likelihood panel (right side)
    function draw() {
      const rect = canvas.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;

      ctx.clearRect(0, 0, width, height);

      // Margins
      const margin = { top: 30, right: 30, bottom: 50, left: 70 };
      const plotWidth = width - margin.left - margin.right;
      const plotHeight = height - margin.top - margin.bottom;

      // Store layout for click detection
      canvasLayout = { margin, plotWidth, plotHeight };

      // Compute likelihood curve
      const nPoints = 200;
      const points = [];
      let minLL = Infinity, maxLL = -Infinity;

      for (let i = 0; i < nPoints; i++) {
        const theta = paramRange.min + (paramRange.max - paramRange.min) * i / (nPoints - 1);
        const ll = logLikelihood(theta);
        if (isFinite(ll)) {
          points.push({ theta, ll });
          minLL = Math.min(minLL, ll);
          maxLL = Math.max(maxLL, ll);
        }
      }

      // Add padding to y-axis
      const llPadding = (maxLL - minLL) * 0.1;
      minLL -= llPadding;
      maxLL += llPadding;

      // Scale functions
      const xScale = (theta) => margin.left + (theta - paramRange.min) / (paramRange.max - paramRange.min) * plotWidth;
      const yScale = (ll) => margin.top + plotHeight - (ll - minLL) / (maxLL - minLL) * plotHeight;

      // Draw axes
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 1;

      // X-axis
      ctx.beginPath();
      ctx.moveTo(margin.left, margin.top + plotHeight);
      ctx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
      ctx.stroke();

      // Y-axis
      ctx.beginPath();
      ctx.moveTo(margin.left, margin.top);
      ctx.lineTo(margin.left, margin.top + plotHeight);
      ctx.stroke();

      // Axis labels
      ctx.fillStyle = '#666';
      ctx.font = '12px -apple-system, sans-serif';
      ctx.textAlign = 'center';

      // X-axis ticks
      const xTicks = 5;
      for (let i = 0; i <= xTicks; i++) {
        const theta = paramRange.min + (paramRange.max - paramRange.min) * i / xTicks;
        const x = xScale(theta);
        ctx.fillText(theta.toFixed(1), x, margin.top + plotHeight + 20);

        ctx.beginPath();
        ctx.moveTo(x, margin.top + plotHeight);
        ctx.lineTo(x, margin.top + plotHeight + 5);
        ctx.stroke();
      }

      // X-axis label
      ctx.font = '14px -apple-system, sans-serif';
      ctx.fillText(getParamLabel(), margin.left + plotWidth / 2, height - 10);

      // Y-axis label
      ctx.save();
      ctx.translate(15, margin.top + plotHeight / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Log-Likelihood', 0, 0);
      ctx.restore();

      // Draw the likelihood curve
      ctx.beginPath();
      ctx.strokeStyle = '#667eea';
      ctx.lineWidth = 3;

      for (let i = 0; i < points.length; i++) {
        const x = xScale(points[i].theta);
        const y = yScale(points[i].ll);
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();

      // Draw history path
      if (history.length > 1) {
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(231, 76, 60, 0.5)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);

        for (let i = 0; i < history.length; i++) {
          const x = xScale(history[i].theta);
          const y = yScale(history[i].ll);
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Draw current estimate
      if (currentEstimate !== null) {
        const ll = logLikelihood(currentEstimate);
        const x = xScale(currentEstimate);
        const y = yScale(ll);

        // Vertical line to curve
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(231, 76, 60, 0.3)';
        ctx.lineWidth = 1;
        ctx.moveTo(x, margin.top + plotHeight);
        ctx.lineTo(x, y);
        ctx.stroke();

        // Point on curve
        ctx.beginPath();
        ctx.fillStyle = '#e74c3c';
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.fill();

        // White inner circle
        ctx.beginPath();
        ctx.fillStyle = 'white';
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fill();
      }

      // Draw true MLE marker
      const mleX = xScale(trueMLE);
      const mleY = yScale(logLikelihood(trueMLE));

      ctx.beginPath();
      ctx.strokeStyle = '#27ae60';
      ctx.lineWidth = 2;
      ctx.setLineDash([3, 3]);
      ctx.moveTo(mleX, margin.top + plotHeight);
      ctx.lineTo(mleX, mleY);
      ctx.stroke();
      ctx.setLineDash([]);

      // MLE label
      ctx.fillStyle = '#27ae60';
      ctx.font = '11px -apple-system, sans-serif';
      ctx.fillText('MLE', mleX, margin.top + plotHeight + 35);
    }

    function getParamLabel() {
      switch (currentDistribution) {
        case 'gaussian': return 'Mean (Î¼)';
        case 'poisson': return 'Rate (Î»)';
        case 'binomial': return 'Probability (p)';
      }
    }

    // Update stats display
    function updateStats() {
      if (currentEstimate !== null) {
        document.getElementById('current-estimate').textContent = currentEstimate.toFixed(3);
        document.getElementById('current-ll').textContent = logLikelihood(currentEstimate).toFixed(2);
      } else {
        document.getElementById('current-estimate').textContent = '--';
        document.getElementById('current-ll').textContent = '--';
      }
      document.getElementById('iteration-count').textContent = iteration;
    }

    // Algorithm step functions
    function algorithmStep() {
      switch (currentAlgorithm) {
        case 'analytic':
          // Jump directly to MLE
          currentEstimate = trueMLE;
          iteration = 1;
          history.push({ theta: currentEstimate, ll: logLikelihood(currentEstimate) });
          isRunning = false;
          break;

        case 'newton':
          // Newton-Raphson: theta_new = theta - f'(theta) / f''(theta)
          if (currentEstimate === null) {
            // Start from a random point
            currentEstimate = paramRange.min + (paramRange.max - paramRange.min) * 0.2;
            history = [{ theta: currentEstimate, ll: logLikelihood(currentEstimate) }];
          }

          const g = gradient(currentEstimate);
          const h = hessian(currentEstimate);

          if (Math.abs(h) > 1e-10) {
            const step = -g / h;
            currentEstimate = currentEstimate + step;

            // Clamp to valid range
            currentEstimate = Math.max(paramRange.min + 0.01,
                              Math.min(paramRange.max - 0.01, currentEstimate));
          }

          iteration++;
          history.push({ theta: currentEstimate, ll: logLikelihood(currentEstimate) });

          // Check convergence
          if (Math.abs(g) < 1e-6 || iteration > 20) {
            isRunning = false;
          }
          break;

        case 'gradient':
          // Gradient descent with adaptive step size
          if (currentEstimate === null) {
            currentEstimate = paramRange.min + (paramRange.max - paramRange.min) * 0.2;
            history = [{ theta: currentEstimate, ll: logLikelihood(currentEstimate) }];
          }

          const grad = gradient(currentEstimate);
          const stepSize = 0.01 * (paramRange.max - paramRange.min);

          currentEstimate = currentEstimate + stepSize * Math.sign(grad);

          // Clamp
          currentEstimate = Math.max(paramRange.min + 0.01,
                            Math.min(paramRange.max - 0.01, currentEstimate));

          iteration++;
          history.push({ theta: currentEstimate, ll: logLikelihood(currentEstimate) });

          // Check convergence
          if (Math.abs(grad) < 1e-4 || iteration > 100) {
            isRunning = false;
          }
          break;
      }

      updateStats();
      drawData();
      draw();
    }

    // Animation loop
    function animate() {
      if (!isRunning) return;

      algorithmStep();

      if (isRunning) {
        const delay = currentAlgorithm === 'gradient' ? 100 : 500;
        animationId = setTimeout(animate, delay);
      }
    }

    // Reset
    function reset() {
      isRunning = false;
      if (animationId) clearTimeout(animationId);
      currentEstimate = null;
      iteration = 0;
      history = [];
      manualAttempts = 0;
      document.getElementById('attempt-count').textContent = '0';
      document.getElementById('start-btn').textContent = 'Start';
      updateStats();
      drawData();
      draw();
    }

    // ========================================
    // Mode switching
    // ========================================

    function setMode(mode) {
      currentMode = mode;

      // Update toggle buttons
      document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === mode);
      });

      // Show/hide controls
      document.getElementById('manual-controls').classList.toggle('hidden', mode !== 'manual');
      document.getElementById('algorithm-controls').classList.toggle('hidden', mode !== 'algorithm');

      // Update canvas cursor
      canvas.classList.toggle('manual-mode', mode === 'manual');

      // Reset state when switching modes
      reset();

      // In manual mode, initialize with slider value
      if (mode === 'manual') {
        updateFromSlider();
      }
    }

    // Mode toggle buttons
    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.addEventListener('click', () => setMode(btn.dataset.mode));
    });

    // ========================================
    // Manual mode: Slider control
    // ========================================

    const slider = document.getElementById('param-slider');
    const sliderValue = document.getElementById('slider-value');
    const paramLabel = document.getElementById('param-label');

    function updateSliderRange() {
      slider.min = paramRange.min;
      slider.max = paramRange.max;
      slider.step = (paramRange.max - paramRange.min) / 500;
      slider.value = (paramRange.min + paramRange.max) / 2;

      // Update label
      paramLabel.textContent = getParamLabel() + ':';
    }

    function updateFromSlider() {
      const value = parseFloat(slider.value);
      currentEstimate = value;
      sliderValue.textContent = value.toFixed(2);
      updateStats();
      drawData();
      draw();
    }

    slider.addEventListener('input', () => {
      manualAttempts++;
      document.getElementById('attempt-count').textContent = manualAttempts;
      updateFromSlider();
    });

    // ========================================
    // Manual mode: Click on canvas
    // ========================================

    canvas.addEventListener('click', (e) => {
      if (currentMode !== 'manual') return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;

      // Convert x to theta
      const { margin, plotWidth } = canvasLayout;

      // Check if click is within plot area
      if (x < margin.left || x > margin.left + plotWidth) return;

      const theta = paramRange.min + (x - margin.left) / plotWidth * (paramRange.max - paramRange.min);

      // Update slider and estimate
      slider.value = theta;
      manualAttempts++;
      document.getElementById('attempt-count').textContent = manualAttempts;
      updateFromSlider();
    });

    // ========================================
    // Algorithm mode controls
    // ========================================

    document.getElementById('distribution-select').addEventListener('change', (e) => {
      currentDistribution = e.target.value;
      generateData();
      updateSliderRange();
      reset();
      if (currentMode === 'manual') {
        updateFromSlider();
      }
    });

    document.getElementById('algorithm-select').addEventListener('change', (e) => {
      currentAlgorithm = e.target.value;
      updateAlgorithmInfo();
      reset();
    });

    document.getElementById('start-btn').addEventListener('click', () => {
      if (isRunning) {
        isRunning = false;
        document.getElementById('start-btn').textContent = 'Start';
      } else {
        isRunning = true;
        document.getElementById('start-btn').textContent = 'Pause';
        animate();
      }
    });

    document.getElementById('step-btn').addEventListener('click', () => {
      isRunning = false;
      document.getElementById('start-btn').textContent = 'Start';
      algorithmStep();
    });

    document.getElementById('reset-btn').addEventListener('click', reset);

    function updateAlgorithmInfo() {
      const info = document.getElementById('algorithm-info');
      switch (currentAlgorithm) {
        case 'analytic':
          info.innerHTML = `
            <h4>Analytic Solution</h4>
            <p>For simple models, we can solve $\\frac{d\\ell}{d\\theta} = 0$ directly.
            For the Gaussian mean, the MLE is simply $\\bar{y}$. No iteration needed!</p>
          `;
          break;
        case 'newton':
          info.innerHTML = `
            <h4>Newton-Raphson</h4>
            <p>Uses both gradient and curvature: $\\theta_{new} = \\theta - \\frac{\\ell'(\\theta)}{\\ell''(\\theta)}$.
            Converges very fast (typically 2-5 iterations) when near the optimum.</p>
          `;
          break;
        case 'gradient':
          info.innerHTML = `
            <h4>Gradient Descent</h4>
            <p>Follows the slope uphill: $\\theta_{new} = \\theta + \\alpha \\cdot \\ell'(\\theta)$.
            Simple but slow &mdash; takes many small steps to reach the peak.</p>
          `;
          break;
      }

      // Re-render math
      if (typeof renderMathInElement !== 'undefined') {
        renderMathInElement(info, {
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false}
          ]
        });
      }
    }

    // Initialize
    window.addEventListener('resize', () => {
      setupCanvas();
      drawData();
      draw();
    });

    setupCanvas();
    generateData();
    updateSliderRange();
    updateAlgorithmInfo();

    // Start in manual mode with initial estimate
    canvas.classList.add('manual-mode');
    updateFromSlider();
  </script>
</body>
</html>
