<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Optimization: Multiple Regression | GLM Explainer</title>
  <!-- Plotly.js for interactive 3D surface -->
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      line-height: 1.6;
      color: #2c3e50;
      background: #f8f9fa;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 30px;
    }

    header h1 {
      font-size: 1.8em;
      color: #2c3e50;
      margin-bottom: 10px;
    }

    header p {
      color: #666;
      font-size: 1.1em;
    }

    .nav-links {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 15px;
    }

    .nav-links a {
      color: #667eea;
      text-decoration: none;
      font-weight: 500;
    }

    .nav-links a:hover {
      text-decoration: underline;
    }

    .nav-links a.current {
      color: #2c3e50;
      font-weight: 600;
    }

    .visualization-card {
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      padding: 25px;
      margin-bottom: 20px;
    }

    .viz-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 15px;
    }

    .viz-title {
      font-size: 1.2em;
      font-weight: 600;
      color: #2c3e50;
    }

    /* Dual canvas layout */
    .canvas-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 15px;
    }

    @media (max-width: 900px) {
      .canvas-grid {
        grid-template-columns: 1fr;
      }
    }

    .canvas-panel {
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 15px;
    }

    .canvas-panel h4 {
      margin: 0 0 10px 0;
      font-size: 0.95em;
      color: #666;
      text-align: center;
    }

    /* Canvas styling */
    #data-canvas, #likelihood-canvas {
      width: 100%;
      height: 380px;
      background: white;
      border: 1px solid #eee;
      border-radius: 4px;
    }

    /* Mode toggle */
    .mode-toggle {
      display: flex;
      background: #e0e0e0;
      border-radius: 8px;
      padding: 4px;
      margin-bottom: 20px;
    }

    .mode-btn {
      flex: 1;
      padding: 10px 20px;
      border: none;
      background: transparent;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      color: #666;
      transition: all 0.2s;
    }

    .mode-btn.active {
      background: white;
      color: #667eea;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .mode-btn:hover:not(.active) {
      color: #2c3e50;
    }

    /* Manual controls */
    .manual-controls {
      background: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: 8px;
      padding: 20px;
      margin-top: 15px;
    }

    .manual-controls.hidden {
      display: none;
    }

    .manual-controls h4 {
      color: #856404;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .manual-controls h4::before {
      content: 'üëÜ';
    }

    .slider-row {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 12px;
    }

    .slider-row label {
      font-weight: 500;
      color: #666;
      min-width: 120px;
    }

    .slider-row input[type="range"] {
      flex: 1;
      height: 8px;
      border-radius: 4px;
      background: #ddd;
      outline: none;
      -webkit-appearance: none;
    }

    .slider-row input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #e74c3c;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .slider-value {
      font-family: 'SF Mono', Monaco, monospace;
      font-weight: 600;
      min-width: 70px;
      text-align: right;
    }

    .manual-hint {
      font-size: 0.9em;
      color: #856404;
      margin-top: 15px;
      font-style: italic;
    }

    .attempts-counter {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid #ffc107;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .attempts-counter span {
      color: #856404;
    }

    .attempts-counter .count {
      font-weight: 600;
      font-size: 1.2em;
    }

    /* View toggle for right panel */
    .view-toggle {
      display: flex;
      background: #e0e0e0;
      border-radius: 6px;
      padding: 3px;
      margin-bottom: 10px;
    }

    .view-btn {
      flex: 1;
      padding: 6px 12px;
      border: none;
      background: transparent;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      font-size: 0.85em;
      color: #666;
      transition: all 0.2s;
    }

    .view-btn.active {
      background: white;
      color: #667eea;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .view-btn:hover:not(.active) {
      color: #2c3e50;
    }

    /* Slice selector */
    .slice-selector {
      background: #e8f4fd;
      border: 1px solid #bee5eb;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
    }

    .slice-selector.hidden {
      display: none;
    }

    .slice-selector h4 {
      color: #0c5460;
      margin-bottom: 10px;
      font-size: 0.95em;
    }

    .slice-options {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
    }

    .slice-options label {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      color: #0c5460;
    }

    /* Algorithm controls */
    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 20px;
      align-items: center;
    }

    .controls.hidden {
      display: none;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .control-group label {
      font-size: 0.9em;
      color: #666;
    }

    select {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 6px;
      background: white;
      font-size: 0.9em;
      cursor: pointer;
    }

    button {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s;
    }

    button.primary {
      background: #667eea;
      color: white;
    }

    button.primary:hover {
      background: #5a6fd6;
    }

    button.secondary {
      background: #95a5a6;
      color: white;
    }

    button.secondary:hover {
      background: #7f8c8d;
    }

    /* Canvas cursor */
    #likelihood-canvas.manual-mode {
      cursor: crosshair;
    }

    /* Stats display */
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 15px;
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid #eee;
    }

    .stat-item {
      text-align: center;
    }

    .stat-item .label {
      font-size: 0.85em;
      color: #666;
      margin-bottom: 4px;
    }

    .stat-item .value {
      font-size: 1.2em;
      font-weight: 600;
      color: #2c3e50;
      font-family: 'SF Mono', Monaco, monospace;
    }

    /* Algorithm info */
    .algorithm-info {
      background: #e8f4fd;
      border: 1px solid #bee5eb;
      border-radius: 8px;
      padding: 15px;
      margin-top: 15px;
    }

    .algorithm-info.hidden {
      display: none;
    }

    .algorithm-info h4 {
      color: #0c5460;
      margin-bottom: 8px;
    }

    .algorithm-info p {
      color: #0c5460;
      font-size: 0.9em;
    }

    /* Explanation section */
    .explanation {
      background: #f8f9fa;
      border-left: 4px solid #667eea;
      padding: 20px;
      margin-top: 20px;
      border-radius: 0 8px 8px 0;
    }

    .explanation h3 {
      color: #2c3e50;
      margin-bottom: 10px;
    }

    .explanation p {
      color: #666;
      margin-bottom: 10px;
    }

    .explanation ul {
      color: #666;
      margin-left: 20px;
    }

    .explanation li {
      margin-bottom: 5px;
    }

    /* Footer */
    footer {
      text-align: center;
      padding: 20px;
      color: #666;
      font-size: 0.9em;
    }

    footer a {
      color: #667eea;
      text-decoration: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>3D Optimization: Multiple Regression</h1>
      <p>Three parameters: intercept (Œ≤‚ÇÄ) and two slopes (Œ≤‚ÇÅ, Œ≤‚ÇÇ)</p>
      <div class="nav-links">
        <a href="index.html">1D (Mean Only)</a>
        <a href="2d.html">2D (Line Fit)</a>
        <a href="3d.html" class="current">3D (Multiple Regression)</a>
        <a href="4d.html">4D+ (Beyond Visualization)</a>
      </div>
    </header>

    <div class="visualization-card">
      <div class="viz-header">
        <span class="viz-title">Multiple Regression: y = Œ≤‚ÇÄ + Œ≤‚ÇÅx‚ÇÅ + Œ≤‚ÇÇx‚ÇÇ</span>
      </div>

      <!-- Mode toggle -->
      <div class="mode-toggle">
        <button class="mode-btn active" data-mode="manual">Try It Yourself</button>
        <button class="mode-btn" data-mode="algorithm">Watch Algorithm</button>
      </div>

      <!-- Dual canvas view -->
      <div class="canvas-grid">
        <div class="canvas-panel">
          <h4>Data + Fitted Plane (3D View)</h4>
          <canvas id="data-canvas"></canvas>
        </div>
        <div class="canvas-panel">
          <h4>Likelihood Surface</h4>
          <!-- View toggle -->
          <div class="view-toggle">
            <button class="view-btn active" data-view="slice">2D Slice</button>
            <button class="view-btn" data-view="full3d">Full 3D</button>
          </div>
          <!-- Slice selector (only shown for 2D slice view) -->
          <div class="slice-selector" id="slice-selector">
            <h4>Fix one parameter, show contour of other two:</h4>
            <div class="slice-options">
              <label>
                <input type="radio" name="slice" value="b0" checked>
                Fix Œ≤‚ÇÄ (show Œ≤‚ÇÅ vs Œ≤‚ÇÇ)
              </label>
              <label>
                <input type="radio" name="slice" value="b1">
                Fix Œ≤‚ÇÅ (show Œ≤‚ÇÄ vs Œ≤‚ÇÇ)
              </label>
              <label>
                <input type="radio" name="slice" value="b2">
                Fix Œ≤‚ÇÇ (show Œ≤‚ÇÄ vs Œ≤‚ÇÅ)
              </label>
            </div>
          </div>
          <canvas id="likelihood-canvas"></canvas>
          <!-- Plotly container for Full 3D view -->
          <div id="plotly-3d" style="width: 100%; height: 340px; display: none;"></div>
        </div>
      </div>

      <!-- Manual mode controls -->
      <div class="manual-controls" id="manual-controls">
        <h4>Find the Peak!</h4>
        <p>Adjust all three sliders to maximize the log-likelihood. The 3D surface is hard to visualize, but the slice view helps!</p>

        <div class="slider-row">
          <label>Intercept (Œ≤‚ÇÄ):</label>
          <input type="range" id="b0-slider" min="-10" max="20" value="5" step="0.2">
          <span class="slider-value" id="b0-value">5.0</span>
        </div>

        <div class="slider-row">
          <label>Slope x‚ÇÅ (Œ≤‚ÇÅ):</label>
          <input type="range" id="b1-slider" min="-5" max="5" value="0" step="0.1">
          <span class="slider-value" id="b1-value">0.0</span>
        </div>

        <div class="slider-row">
          <label>Slope x‚ÇÇ (Œ≤‚ÇÇ):</label>
          <input type="range" id="b2-slider" min="-5" max="5" value="0" step="0.1">
          <span class="slider-value" id="b2-value">0.0</span>
        </div>

        <p class="manual-hint">Tip: Try fixing one parameter at its MLE value, then adjust the other two using the slice view!</p>

        <div class="attempts-counter">
          <span>Adjustments made:</span>
          <span class="count" id="attempt-count">0</span>
        </div>
      </div>

      <!-- Algorithm mode controls -->
      <div class="controls hidden" id="algorithm-controls">
        <div class="control-group">
          <label for="algorithm-select">Algorithm:</label>
          <select id="algorithm-select">
            <option value="analytic">Analytic (OLS)</option>
            <option value="newton">Newton-Raphson</option>
            <option value="gradient">Gradient Descent</option>
          </select>
        </div>

        <button class="primary" id="start-btn">Start</button>
        <button class="secondary" id="reset-btn">Reset</button>
      </div>

      <!-- Algorithm info -->
      <div class="algorithm-info hidden" id="algorithm-info">
        <h4 id="algo-name">Analytic Solution</h4>
        <p id="algo-desc">Computes the exact MLE using matrix algebra: Œ≤ = (X'X)‚Åª¬πX'y</p>
      </div>

      <!-- Stats display -->
      <div class="stats">
        <div class="stat-item">
          <div class="label">Œ≤‚ÇÄ (Intercept)</div>
          <div class="value" id="current-b0">--</div>
        </div>
        <div class="stat-item">
          <div class="label">Œ≤‚ÇÅ (Slope x‚ÇÅ)</div>
          <div class="value" id="current-b1">--</div>
        </div>
        <div class="stat-item">
          <div class="label">Œ≤‚ÇÇ (Slope x‚ÇÇ)</div>
          <div class="value" id="current-b2">--</div>
        </div>
        <div class="stat-item">
          <div class="label">Log-Likelihood</div>
          <div class="value" id="current-ll">--</div>
        </div>
        <div class="stat-item">
          <div class="label">Iterations</div>
          <div class="value" id="iteration-count">0</div>
        </div>
      </div>
    </div>

    <!-- Explanation -->
    <div class="explanation">
      <h3>Swimming Through Parameter Space</h3>
      <p>With 3 parameters, the likelihood becomes a <strong>4D object</strong>: three dimensions for the parameters (Œ≤‚ÇÄ, Œ≤‚ÇÅ, Œ≤‚ÇÇ) and a fourth for the likelihood value itself.</p>
      <ul>
        <li><strong>Full 3D view:</strong> Shows nested "shells" of likelihood &mdash; dark red = high likelihood, blue = low. The algorithm "swims" toward the darkest red region.</li>
        <li><strong>2D slice view:</strong> Fixes one parameter to show a 2D contour of the other two &mdash; easier to interpret but loses information.</li>
        <li><strong>The MLE</strong> sits at the "hottest" point in the volume &mdash; the center of the red region where all gradients are zero.</li>
        <li><strong>Real GLMs</strong> have dozens or hundreds of parameters &mdash; imagine navigating a 100-dimensional space!</li>
      </ul>
      <p style="margin-top: 15px;">
        This is the <strong>curse of dimensionality</strong>: we can't visualize high-dimensional spaces,
        so we rely on algorithms to navigate them mathematically. The gradient tells us "which way is up"
        even when we can't see the landscape.
      </p>
    </div>

    <footer>
      <a href="../index.html">‚Üê Back to Tutorials</a>
    </footer>
  </div>

  <script>
    // ========================================
    // 3D Likelihood Visualization
    // ========================================

    const canvas = document.getElementById('likelihood-canvas');
    const ctx = canvas.getContext('2d');
    const dataCanvas = document.getElementById('data-canvas');
    const dataCtx = dataCanvas.getContext('2d');

    // High DPI support
    function setupCanvas() {
      const dpr = window.devicePixelRatio || 1;

      // Likelihood canvas
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.scale(dpr, dpr);
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';

      // Data canvas
      const dataRect = dataCanvas.getBoundingClientRect();
      dataCanvas.width = dataRect.width * dpr;
      dataCanvas.height = dataRect.height * dpr;
      dataCtx.scale(dpr, dpr);
      dataCanvas.style.width = dataRect.width + 'px';
      dataCanvas.style.height = dataRect.height + 'px';
    }

    // State
    let currentMode = 'manual';
    let currentAlgorithm = 'analytic';
    let currentView = 'slice'; // 'slice' or 'full3d'
    let currentB0 = 5;
    let currentB1 = 0;
    let currentB2 = 0;
    let currentSlice = 'b0'; // Which parameter is fixed in the slice view
    let iteration = 0;
    let isRunning = false;
    let animationId = null;
    let history = [];
    let manualAttempts = 0;

    // True parameters for data generation
    const trueB0 = 5;
    const trueB1 = 2;
    const trueB2 = -1.5;
    const n = 40;
    let data = [];

    // MLE estimates
    let mleB0 = 0, mleB1 = 0, mleB2 = 0;

    // Parameter ranges
    const b0Range = { min: -5, max: 15 };
    const b1Range = { min: -4, max: 6 };
    const b2Range = { min: -5, max: 3 };

    // Generate sample data
    function generateData() {
      data = [];
      for (let i = 0; i < n; i++) {
        const x1 = Math.random() * 10 - 5; // x1 in [-5, 5]
        const x2 = Math.random() * 10 - 5; // x2 in [-5, 5]
        const noise = (Math.random() - 0.5) * 10; // noise
        const y = trueB0 + trueB1 * x1 + trueB2 * x2 + noise;
        data.push({ x1, x2, y });
      }

      computeMLE();
    }

    // Compute OLS estimates
    function computeMLE() {
      // Using normal equations: Œ≤ = (X'X)^(-1) X'y
      // Build matrices
      let X = data.map(d => [1, d.x1, d.x2]);
      let Y = data.map(d => d.y);

      // X'X
      let XtX = [[0,0,0], [0,0,0], [0,0,0]];
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < 3; j++) {
          for (let k = 0; k < 3; k++) {
            XtX[j][k] += X[i][j] * X[i][k];
          }
        }
      }

      // X'y
      let XtY = [0, 0, 0];
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < 3; j++) {
          XtY[j] += X[i][j] * Y[i];
        }
      }

      // Invert 3x3 matrix
      const inv = invert3x3(XtX);

      // Œ≤ = inv(X'X) * X'y
      mleB0 = inv[0][0]*XtY[0] + inv[0][1]*XtY[1] + inv[0][2]*XtY[2];
      mleB1 = inv[1][0]*XtY[0] + inv[1][1]*XtY[1] + inv[1][2]*XtY[2];
      mleB2 = inv[2][0]*XtY[0] + inv[2][1]*XtY[1] + inv[2][2]*XtY[2];
    }

    // 3x3 matrix inversion
    function invert3x3(m) {
      const det = m[0][0]*(m[1][1]*m[2][2] - m[1][2]*m[2][1])
                - m[0][1]*(m[1][0]*m[2][2] - m[1][2]*m[2][0])
                + m[0][2]*(m[1][0]*m[2][1] - m[1][1]*m[2][0]);

      const inv = [
        [(m[1][1]*m[2][2] - m[1][2]*m[2][1])/det, (m[0][2]*m[2][1] - m[0][1]*m[2][2])/det, (m[0][1]*m[1][2] - m[0][2]*m[1][1])/det],
        [(m[1][2]*m[2][0] - m[1][0]*m[2][2])/det, (m[0][0]*m[2][2] - m[0][2]*m[2][0])/det, (m[0][2]*m[1][0] - m[0][0]*m[1][2])/det],
        [(m[1][0]*m[2][1] - m[1][1]*m[2][0])/det, (m[0][1]*m[2][0] - m[0][0]*m[2][1])/det, (m[0][0]*m[1][1] - m[0][1]*m[1][0])/det]
      ];
      return inv;
    }

    // Log-likelihood
    function logLikelihood(b0, b1, b2) {
      let ss = 0;
      for (const d of data) {
        const pred = b0 + b1 * d.x1 + b2 * d.x2;
        const resid = d.y - pred;
        ss += resid * resid;
      }
      const sigma2 = 25; // known variance
      return -n/2 * Math.log(2 * Math.PI * sigma2) - ss / (2 * sigma2);
    }

    // Gradient
    function gradient(b0, b1, b2) {
      let g0 = 0, g1 = 0, g2 = 0;
      const sigma2 = 25;
      for (const d of data) {
        const resid = d.y - (b0 + b1 * d.x1 + b2 * d.x2);
        g0 += resid;
        g1 += resid * d.x1;
        g2 += resid * d.x2;
      }
      return [g0 / sigma2, g1 / sigma2, g2 / sigma2];
    }

    // Hessian (for Newton-Raphson)
    // For Gaussian regression, the Hessian is constant: H = -X'X / œÉ¬≤
    function hessian() {
      const sigma2 = 25;
      let H = [[0,0,0], [0,0,0], [0,0,0]];
      for (const d of data) {
        const x = [1, d.x1, d.x2];
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            H[i][j] -= x[i] * x[j] / sigma2;
          }
        }
      }
      return H;
    }

    // Canvas layout
    let canvasLayout = {
      margin: { top: 40, right: 30, bottom: 50, left: 60 },
      plotWidth: 0,
      plotHeight: 0
    };

    // 3D projection for isometric view
    function project3D(x1, x2, y, width, height) {
      const centerX = width / 2;
      const centerY = height / 2 + 30;
      const scale = 12;

      // Isometric projection with rotation
      const angle = Math.PI / 6;
      const px = centerX + scale * (x1 * Math.cos(angle) - x2 * Math.cos(angle));
      const py = centerY - scale * (y * 0.6 - x1 * Math.sin(angle) - x2 * Math.sin(angle));

      return { x: px, y: py };
    }

    // Draw the 3D data panel (left side)
    function drawData() {
      const rect = dataCanvas.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;

      dataCtx.clearRect(0, 0, width, height);

      const margin = { top: 20, right: 20, bottom: 30, left: 20 };

      // Draw axes
      const origin = project3D(0, 0, 0, width, height);
      const xEnd = project3D(6, 0, 0, width, height);
      const yEnd = project3D(0, 6, 0, width, height);
      const zEnd = project3D(0, 0, 20, width, height);

      dataCtx.strokeStyle = '#999';
      dataCtx.lineWidth = 1;

      // X1 axis
      dataCtx.beginPath();
      dataCtx.moveTo(origin.x, origin.y);
      dataCtx.lineTo(xEnd.x, xEnd.y);
      dataCtx.stroke();
      dataCtx.fillStyle = '#666';
      dataCtx.font = '11px -apple-system, sans-serif';
      dataCtx.fillText('x‚ÇÅ', xEnd.x + 5, xEnd.y);

      // X2 axis
      dataCtx.beginPath();
      dataCtx.moveTo(origin.x, origin.y);
      dataCtx.lineTo(yEnd.x, yEnd.y);
      dataCtx.stroke();
      dataCtx.fillText('x‚ÇÇ', yEnd.x - 15, yEnd.y);

      // Y (response) axis
      dataCtx.beginPath();
      dataCtx.moveTo(origin.x, origin.y);
      dataCtx.lineTo(zEnd.x, zEnd.y);
      dataCtx.stroke();
      dataCtx.fillText('y', zEnd.x + 5, zEnd.y);

      // Draw fitted plane (as a grid)
      dataCtx.strokeStyle = 'rgba(231, 76, 60, 0.3)';
      dataCtx.lineWidth = 1;

      const gridSize = 5;
      for (let i = -gridSize; i <= gridSize; i += 2) {
        // Lines along x1
        const p1 = project3D(i, -gridSize, currentB0 + currentB1 * i + currentB2 * (-gridSize), width, height);
        const p2 = project3D(i, gridSize, currentB0 + currentB1 * i + currentB2 * gridSize, width, height);
        dataCtx.beginPath();
        dataCtx.moveTo(p1.x, p1.y);
        dataCtx.lineTo(p2.x, p2.y);
        dataCtx.stroke();

        // Lines along x2
        const p3 = project3D(-gridSize, i, currentB0 + currentB1 * (-gridSize) + currentB2 * i, width, height);
        const p4 = project3D(gridSize, i, currentB0 + currentB1 * gridSize + currentB2 * i, width, height);
        dataCtx.beginPath();
        dataCtx.moveTo(p3.x, p3.y);
        dataCtx.lineTo(p4.x, p4.y);
        dataCtx.stroke();
      }

      // Draw MLE plane edges
      dataCtx.strokeStyle = 'rgba(39, 174, 96, 0.5)';
      dataCtx.lineWidth = 2;
      dataCtx.setLineDash([4, 4]);

      const mleCorners = [
        project3D(-gridSize, -gridSize, mleB0 + mleB1 * (-gridSize) + mleB2 * (-gridSize), width, height),
        project3D(gridSize, -gridSize, mleB0 + mleB1 * gridSize + mleB2 * (-gridSize), width, height),
        project3D(gridSize, gridSize, mleB0 + mleB1 * gridSize + mleB2 * gridSize, width, height),
        project3D(-gridSize, gridSize, mleB0 + mleB1 * (-gridSize) + mleB2 * gridSize, width, height)
      ];

      dataCtx.beginPath();
      dataCtx.moveTo(mleCorners[0].x, mleCorners[0].y);
      for (let i = 1; i < 4; i++) {
        dataCtx.lineTo(mleCorners[i].x, mleCorners[i].y);
      }
      dataCtx.closePath();
      dataCtx.stroke();
      dataCtx.setLineDash([]);

      // Draw data points (sorted by depth for proper occlusion)
      const sortedData = [...data].sort((a, b) => (a.x1 + a.x2) - (b.x1 + b.x2));

      for (const d of sortedData) {
        const p = project3D(d.x1, d.x2, d.y, width, height);
        const pred = currentB0 + currentB1 * d.x1 + currentB2 * d.x2;
        const pPred = project3D(d.x1, d.x2, pred, width, height);

        // Residual line
        dataCtx.strokeStyle = 'rgba(231, 76, 60, 0.3)';
        dataCtx.lineWidth = 1;
        dataCtx.beginPath();
        dataCtx.moveTo(p.x, p.y);
        dataCtx.lineTo(pPred.x, pPred.y);
        dataCtx.stroke();

        // Data point
        dataCtx.fillStyle = '#667eea';
        dataCtx.beginPath();
        dataCtx.arc(p.x, p.y, 4, 0, Math.PI * 2);
        dataCtx.fill();
      }

      // Legend
      dataCtx.fillStyle = '#666';
      dataCtx.font = '11px -apple-system, sans-serif';
      dataCtx.fillText('Red grid: Current fit', 10, height - 30);
      dataCtx.fillStyle = '#27ae60';
      dataCtx.fillText('Green outline: MLE fit', 10, height - 15);
    }

    // Draw the 2D likelihood slice panel (right side)
    function drawSlice() {
      const rect = canvas.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;

      ctx.clearRect(0, 0, width, height);

      const margin = { top: 40, right: 30, bottom: 50, left: 60 };
      const plotWidth = width - margin.left - margin.right;
      const plotHeight = height - margin.top - margin.bottom;

      canvasLayout = { margin, plotWidth, plotHeight };

      // Determine which parameters to show based on slice selection
      let xParam, yParam, fixedParam, fixedValue;
      let xRange, yRange;
      let xLabel, yLabel;

      switch (currentSlice) {
        case 'b0':
          xParam = 'b1'; yParam = 'b2';
          fixedParam = 'Œ≤‚ÇÄ'; fixedValue = currentB0;
          xRange = b1Range; yRange = b2Range;
          xLabel = 'Œ≤‚ÇÅ (Slope x‚ÇÅ)'; yLabel = 'Œ≤‚ÇÇ (Slope x‚ÇÇ)';
          break;
        case 'b1':
          xParam = 'b0'; yParam = 'b2';
          fixedParam = 'Œ≤‚ÇÅ'; fixedValue = currentB1;
          xRange = b0Range; yRange = b2Range;
          xLabel = 'Œ≤‚ÇÄ (Intercept)'; yLabel = 'Œ≤‚ÇÇ (Slope x‚ÇÇ)';
          break;
        case 'b2':
          xParam = 'b0'; yParam = 'b1';
          fixedParam = 'Œ≤‚ÇÇ'; fixedValue = currentB2;
          xRange = b0Range; yRange = b1Range;
          xLabel = 'Œ≤‚ÇÄ (Intercept)'; yLabel = 'Œ≤‚ÇÅ (Slope x‚ÇÅ)';
          break;
      }

      // Compute likelihood surface for this slice
      const gridSize = 40;
      const llGrid = [];
      let minLL = Infinity, maxLL = -Infinity;

      for (let i = 0; i < gridSize; i++) {
        llGrid[i] = [];
        const xVal = xRange.min + (xRange.max - xRange.min) * i / (gridSize - 1);
        for (let j = 0; j < gridSize; j++) {
          const yVal = yRange.min + (yRange.max - yRange.min) * j / (gridSize - 1);

          let ll;
          switch (currentSlice) {
            case 'b0': ll = logLikelihood(currentB0, xVal, yVal); break;
            case 'b1': ll = logLikelihood(xVal, currentB1, yVal); break;
            case 'b2': ll = logLikelihood(xVal, yVal, currentB2); break;
          }

          llGrid[i][j] = ll;
          if (isFinite(ll)) {
            minLL = Math.min(minLL, ll);
            maxLL = Math.max(maxLL, ll);
          }
        }
      }

      // Scale functions
      const xScale = (val) => margin.left + (val - xRange.min) / (xRange.max - xRange.min) * plotWidth;
      const yScale = (val) => margin.top + plotHeight - (val - yRange.min) / (yRange.max - yRange.min) * plotHeight;

      // Draw filled contours
      const cellWidth = plotWidth / (gridSize - 1);
      const cellHeight = plotHeight / (gridSize - 1);

      for (let i = 0; i < gridSize - 1; i++) {
        for (let j = 0; j < gridSize - 1; j++) {
          const ll = (llGrid[i][j] + llGrid[i+1][j] + llGrid[i][j+1] + llGrid[i+1][j+1]) / 4;
          const normalized = (ll - minLL) / (maxLL - minLL);

          const r = Math.round(255 * normalized);
          const g = Math.round(255 * normalized);
          const b = Math.round(255 * (1 - normalized * 0.5));

          ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;

          const xVal = xRange.min + (xRange.max - xRange.min) * i / (gridSize - 1);
          const yVal = yRange.min + (yRange.max - yRange.min) * j / (gridSize - 1);

          ctx.fillRect(xScale(xVal), yScale(yVal) - cellHeight, cellWidth + 1, cellHeight + 1);
        }
      }

      // Draw contour lines
      const nContours = 8;
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.lineWidth = 1;

      for (let c = 1; c < nContours; c++) {
        const level = minLL + (maxLL - minLL) * c / nContours;
        drawContourLine(llGrid, level, gridSize, xScale, yScale, xRange, yRange);
      }

      // Draw axes
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;

      ctx.beginPath();
      ctx.moveTo(margin.left, margin.top + plotHeight);
      ctx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(margin.left, margin.top);
      ctx.lineTo(margin.left, margin.top + plotHeight);
      ctx.stroke();

      // Axis labels
      ctx.fillStyle = '#333';
      ctx.font = '12px -apple-system, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(xLabel, margin.left + plotWidth / 2, height - 10);

      ctx.save();
      ctx.translate(15, margin.top + plotHeight / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();

      // Fixed parameter label
      ctx.fillStyle = '#0c5460';
      ctx.font = 'bold 11px -apple-system, sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText(`${fixedParam} = ${fixedValue.toFixed(2)} (fixed)`, margin.left + 5, margin.top - 10);

      // Draw MLE point
      let mleX, mleY;
      switch (currentSlice) {
        case 'b0': mleX = xScale(mleB1); mleY = yScale(mleB2); break;
        case 'b1': mleX = xScale(mleB0); mleY = yScale(mleB2); break;
        case 'b2': mleX = xScale(mleB0); mleY = yScale(mleB1); break;
      }

      ctx.beginPath();
      ctx.fillStyle = '#27ae60';
      ctx.arc(mleX, mleY, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.fillStyle = 'white';
      ctx.arc(mleX, mleY, 5, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#27ae60';
      ctx.font = 'bold 11px -apple-system, sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('MLE', mleX + 15, mleY + 4);

      // Draw current estimate
      let curX, curY;
      switch (currentSlice) {
        case 'b0': curX = xScale(currentB1); curY = yScale(currentB2); break;
        case 'b1': curX = xScale(currentB0); curY = yScale(currentB2); break;
        case 'b2': curX = xScale(currentB0); curY = yScale(currentB1); break;
      }

      ctx.beginPath();
      ctx.fillStyle = '#e74c3c';
      ctx.arc(curX, curY, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.fillStyle = 'white';
      ctx.arc(curX, curY, 4, 0, Math.PI * 2);
      ctx.fill();

      // Draw history path
      if (history.length > 1) {
        ctx.beginPath();
        ctx.strokeStyle = '#e74c3c';
        ctx.lineWidth = 2;

        for (let i = 0; i < history.length; i++) {
          let hx, hy;
          switch (currentSlice) {
            case 'b0': hx = xScale(history[i].b1); hy = yScale(history[i].b2); break;
            case 'b1': hx = xScale(history[i].b0); hy = yScale(history[i].b2); break;
            case 'b2': hx = xScale(history[i].b0); hy = yScale(history[i].b1); break;
          }
          if (i === 0) {
            ctx.moveTo(hx, hy);
          } else {
            ctx.lineTo(hx, hy);
          }
        }
        ctx.stroke();
      }
    }

    // Contour line drawing
    function drawContourLine(grid, level, size, xScale, yScale, xRange, yRange) {
      for (let i = 0; i < size - 1; i++) {
        for (let j = 0; j < size - 1; j++) {
          const v00 = grid[i][j];
          const v10 = grid[i+1][j];
          const v01 = grid[i][j+1];
          const v11 = grid[i+1][j+1];

          const min = Math.min(v00, v10, v01, v11);
          const max = Math.max(v00, v10, v01, v11);

          if (level >= min && level <= max) {
            const x0 = xRange.min + (xRange.max - xRange.min) * i / (size - 1);
            const x1 = xRange.min + (xRange.max - xRange.min) * (i + 1) / (size - 1);
            const y0 = yRange.min + (yRange.max - yRange.min) * j / (size - 1);
            const y1 = yRange.min + (yRange.max - yRange.min) * (j + 1) / (size - 1);

            const points = [];

            if ((v00 - level) * (v10 - level) < 0) {
              const t = (level - v00) / (v10 - v00);
              points.push({ x: xScale(x0 + t * (x1 - x0)), y: yScale(y0) });
            }
            if ((v01 - level) * (v11 - level) < 0) {
              const t = (level - v01) / (v11 - v01);
              points.push({ x: xScale(x0 + t * (x1 - x0)), y: yScale(y1) });
            }
            if ((v00 - level) * (v01 - level) < 0) {
              const t = (level - v00) / (v01 - v00);
              points.push({ x: xScale(x0), y: yScale(y0 + t * (y1 - y0)) });
            }
            if ((v10 - level) * (v11 - level) < 0) {
              const t = (level - v10) / (v11 - v10);
              points.push({ x: xScale(x1), y: yScale(y0 + t * (y1 - y0)) });
            }

            if (points.length >= 2) {
              ctx.beginPath();
              ctx.moveTo(points[0].x, points[0].y);
              ctx.lineTo(points[1].x, points[1].y);
              ctx.stroke();
            }
          }
        }
      }
    }

    // Draw full 3D likelihood volume using Plotly isosurfaces
    // True 3D: x=Œ≤‚ÇÄ, y=Œ≤‚ÇÅ, z=Œ≤‚ÇÇ, color=log-likelihood
    let plotlyInitialized = false;

    function drawFull3D() {
      const plotlyDiv = document.getElementById('plotly-3d');

      // Compute 3D likelihood volume
      // All three parameters vary: Œ≤‚ÇÄ, Œ≤‚ÇÅ, Œ≤‚ÇÇ
      const gridSize = 15; // Keep smaller for performance
      const b0Vals = [];
      const b1Vals = [];
      const b2Vals = [];

      for (let i = 0; i <= gridSize; i++) {
        b0Vals.push(b0Range.min + (b0Range.max - b0Range.min) * i / gridSize);
        b1Vals.push(b1Range.min + (b1Range.max - b1Range.min) * i / gridSize);
        b2Vals.push(b2Range.min + (b2Range.max - b2Range.min) * i / gridSize);
      }

      // Compute log-likelihood at each point in 3D grid
      // Flatten for isosurface format
      const xFlat = [], yFlat = [], zFlat = [], llFlat = [];
      let minLL = Infinity, maxLL = -Infinity;

      for (let i = 0; i <= gridSize; i++) {
        for (let j = 0; j <= gridSize; j++) {
          for (let k = 0; k <= gridSize; k++) {
            const ll = logLikelihood(b0Vals[i], b1Vals[j], b2Vals[k]);
            xFlat.push(b0Vals[i]);
            yFlat.push(b1Vals[j]);
            zFlat.push(b2Vals[k]);
            llFlat.push(ll);
            if (isFinite(ll)) {
              minLL = Math.min(minLL, ll);
              maxLL = Math.max(maxLL, ll);
            }
          }
        }
      }

      // Create isosurface showing nested likelihood shells
      // Higher likelihood = warmer color, closer to center
      const isoTrace = {
        type: 'isosurface',
        x: xFlat,
        y: yFlat,
        z: zFlat,
        value: llFlat,
        isomin: minLL + (maxLL - minLL) * 0.5, // Show top 50% of likelihood
        isomax: maxLL,
        surface: { count: 5 }, // 5 nested shells
        colorscale: [
          [0, 'rgb(100, 150, 255)'],    // Cool blue = lower likelihood
          [0.3, 'rgb(255, 255, 150)'],  // Yellow = medium
          [0.6, 'rgb(255, 150, 50)'],   // Orange = higher
          [1, 'rgb(200, 0, 0)']         // Dark red = highest likelihood
        ],
        opacity: 0.3,
        caps: { x: { show: false }, y: { show: false }, z: { show: false } },
        showscale: true,
        colorbar: {
          title: 'Log-‚Ñì',
          titleside: 'right',
          thickness: 15,
          len: 0.5
        },
        hovertemplate: 'Œ≤‚ÇÄ: %{x:.2f}<br>Œ≤‚ÇÅ: %{y:.2f}<br>Œ≤‚ÇÇ: %{z:.2f}<br>Log-‚Ñì: %{value:.1f}<extra></extra>'
      };

      // MLE point - the "target" at the center of the hottest region
      const mleTrace = {
        type: 'scatter3d',
        mode: 'markers+text',
        x: [mleB0],
        y: [mleB1],
        z: [mleB2],
        marker: {
          size: 12,
          color: '#27ae60',
          symbol: 'diamond',
          line: { color: 'white', width: 2 }
        },
        text: ['MLE'],
        textposition: 'top center',
        textfont: { color: '#27ae60', size: 12, family: 'Arial Black' },
        hovertemplate: 'MLE<br>Œ≤‚ÇÄ: %{x:.2f}<br>Œ≤‚ÇÅ: %{y:.2f}<br>Œ≤‚ÇÇ: %{z:.2f}<extra></extra>',
        name: 'MLE'
      };

      // Current estimate point - "swimming" through the volume
      const currentTrace = {
        type: 'scatter3d',
        mode: 'markers+text',
        x: [currentB0],
        y: [currentB1],
        z: [currentB2],
        marker: {
          size: 10,
          color: '#e74c3c',
          symbol: 'circle',
          line: { color: 'white', width: 1 }
        },
        text: ['Current'],
        textposition: 'top center',
        textfont: { color: '#e74c3c', size: 11 },
        hovertemplate: 'Current<br>Œ≤‚ÇÄ: %{x:.2f}<br>Œ≤‚ÇÅ: %{y:.2f}<br>Œ≤‚ÇÇ: %{z:.2f}<extra></extra>',
        name: 'Current'
      };

      const traces = [isoTrace, mleTrace, currentTrace];

      // Algorithm path - showing the journey through parameter space
      if (history.length > 1) {
        const pathTrace = {
          type: 'scatter3d',
          mode: 'lines+markers',
          x: history.map(h => h.b0),
          y: history.map(h => h.b1),
          z: history.map(h => h.b2),
          line: { color: '#e74c3c', width: 5 },
          marker: { size: 4, color: '#e74c3c' },
          hovertemplate: 'Step<br>Œ≤‚ÇÄ: %{x:.2f}<br>Œ≤‚ÇÅ: %{y:.2f}<br>Œ≤‚ÇÇ: %{z:.2f}<extra></extra>',
          name: 'Path'
        };
        traces.push(pathTrace);
      }

      const layout = {
        title: {
          text: '3D Parameter Space: Swimming to the MLE',
          font: { size: 14 }
        },
        scene: {
          xaxis: { title: 'Œ≤‚ÇÄ (Intercept)', titlefont: { size: 11 } },
          yaxis: { title: 'Œ≤‚ÇÅ (Slope x‚ÇÅ)', titlefont: { size: 11 } },
          zaxis: { title: 'Œ≤‚ÇÇ (Slope x‚ÇÇ)', titlefont: { size: 11 } },
          camera: { eye: { x: 1.8, y: 1.8, z: 1.2 } }
        },
        margin: { l: 0, r: 0, t: 40, b: 0 },
        showlegend: false,
        annotations: [{
          text: 'Dark red = high likelihood ‚Ä¢ Drag to rotate',
          showarrow: false,
          x: 0.5,
          y: -0.02,
          xref: 'paper',
          yref: 'paper',
          font: { size: 10, color: '#666' }
        }]
      };

      const config = {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToRemove: ['toImage', 'sendDataToCloud'],
        displaylogo: false
      };

      if (!plotlyInitialized) {
        Plotly.newPlot(plotlyDiv, traces, layout, config);
        plotlyInitialized = true;
      } else {
        Plotly.react(plotlyDiv, traces, layout, config);
      }
    }

    // Main draw dispatcher
    function drawLikelihood() {
      const plotlyDiv = document.getElementById('plotly-3d');

      if (currentView === 'full3d') {
        canvas.style.display = 'none';
        plotlyDiv.style.display = 'block';
        drawFull3D();
      } else {
        canvas.style.display = 'block';
        plotlyDiv.style.display = 'none';
        drawSlice();
      }
    }

    // Update stats display
    function updateStats() {
      document.getElementById('current-b0').textContent = currentB0.toFixed(2);
      document.getElementById('current-b1').textContent = currentB1.toFixed(2);
      document.getElementById('current-b2').textContent = currentB2.toFixed(2);
      document.getElementById('current-ll').textContent = logLikelihood(currentB0, currentB1, currentB2).toFixed(2);
      document.getElementById('iteration-count').textContent = iteration;
    }

    // Algorithm step
    function algorithmStep() {
      switch (currentAlgorithm) {
        case 'analytic':
          currentB0 = mleB0;
          currentB1 = mleB1;
          currentB2 = mleB2;
          iteration = 1;
          history.push({ b0: currentB0, b1: currentB1, b2: currentB2 });
          isRunning = false;
          break;

        case 'newton':
          // Newton-Raphson: Œ≤_new = Œ≤ - H^(-1) * g
          const gN = gradient(currentB0, currentB1, currentB2);
          const H = hessian();
          const Hinv = invert3x3(H);

          // Compute the update: -H^(-1) * g
          const delta0 = -(Hinv[0][0]*gN[0] + Hinv[0][1]*gN[1] + Hinv[0][2]*gN[2]);
          const delta1 = -(Hinv[1][0]*gN[0] + Hinv[1][1]*gN[1] + Hinv[1][2]*gN[2]);
          const delta2 = -(Hinv[2][0]*gN[0] + Hinv[2][1]*gN[1] + Hinv[2][2]*gN[2]);

          currentB0 += delta0;
          currentB1 += delta1;
          currentB2 += delta2;
          iteration++;
          history.push({ b0: currentB0, b1: currentB1, b2: currentB2 });

          // Check convergence
          const deltaMag = Math.sqrt(delta0*delta0 + delta1*delta1 + delta2*delta2);
          if (deltaMag < 0.001 || iteration > 20) {
            isRunning = false;
          }
          break;

        case 'gradient':
          const [g0, g1, g2] = gradient(currentB0, currentB1, currentB2);

          // Adaptive learning rates
          const lr0 = 0.08;
          const lr1 = 0.015;
          const lr2 = 0.015;

          currentB0 += lr0 * g0;
          currentB1 += lr1 * g1;
          currentB2 += lr2 * g2;
          iteration++;
          history.push({ b0: currentB0, b1: currentB1, b2: currentB2 });

          const gradMag = Math.sqrt(g0*g0 + g1*g1 + g2*g2);
          if (gradMag < 0.01 || iteration > 300) {
            isRunning = false;
          }
          break;
      }

      updateSliders();
      updateStats();
      drawData();
      drawLikelihood();
    }

    // Animation loop
    function animate() {
      if (!isRunning) return;

      algorithmStep();

      if (isRunning) {
        animationId = setTimeout(animate, 150);
      }
    }

    // Reset
    function reset() {
      isRunning = false;
      if (animationId) clearTimeout(animationId);

      // Random starting point
      currentB0 = b0Range.min + Math.random() * (b0Range.max - b0Range.min);
      currentB1 = b1Range.min + Math.random() * (b1Range.max - b1Range.min);
      currentB2 = b2Range.min + Math.random() * (b2Range.max - b2Range.min);

      iteration = 0;
      history = [{ b0: currentB0, b1: currentB1, b2: currentB2 }];
      manualAttempts = 0;
      document.getElementById('attempt-count').textContent = '0';
      document.getElementById('start-btn').textContent = 'Start';

      updateSliders();
      updateStats();
      drawData();
      drawLikelihood();
    }

    // Mode switching
    function setMode(mode) {
      currentMode = mode;

      document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === mode);
      });

      document.getElementById('manual-controls').classList.toggle('hidden', mode !== 'manual');
      document.getElementById('algorithm-controls').classList.toggle('hidden', mode !== 'algorithm');
      document.getElementById('algorithm-info').classList.toggle('hidden', mode !== 'algorithm');

      canvas.classList.toggle('manual-mode', mode === 'manual');

      reset();

      if (mode === 'manual') {
        currentB0 = 5;
        currentB1 = 0;
        currentB2 = 0;
        updateSliders();
        updateFromSliders();
      }
    }

    // Update sliders to match current values
    function updateSliders() {
      document.getElementById('b0-slider').value = currentB0;
      document.getElementById('b0-value').textContent = currentB0.toFixed(1);

      document.getElementById('b1-slider').value = currentB1;
      document.getElementById('b1-value').textContent = currentB1.toFixed(2);

      document.getElementById('b2-slider').value = currentB2;
      document.getElementById('b2-value').textContent = currentB2.toFixed(2);
    }

    // Update from sliders
    function updateFromSliders() {
      currentB0 = parseFloat(document.getElementById('b0-slider').value);
      currentB1 = parseFloat(document.getElementById('b1-slider').value);
      currentB2 = parseFloat(document.getElementById('b2-slider').value);

      document.getElementById('b0-value').textContent = currentB0.toFixed(1);
      document.getElementById('b1-value').textContent = currentB1.toFixed(2);
      document.getElementById('b2-value').textContent = currentB2.toFixed(2);

      updateStats();
      drawData();
      drawLikelihood();
    }

    // Event listeners
    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.addEventListener('click', () => setMode(btn.dataset.mode));
    });

    document.getElementById('b0-slider').addEventListener('input', () => {
      manualAttempts++;
      document.getElementById('attempt-count').textContent = manualAttempts;
      updateFromSliders();
    });

    document.getElementById('b1-slider').addEventListener('input', () => {
      manualAttempts++;
      document.getElementById('attempt-count').textContent = manualAttempts;
      updateFromSliders();
    });

    document.getElementById('b2-slider').addEventListener('input', () => {
      manualAttempts++;
      document.getElementById('attempt-count').textContent = manualAttempts;
      updateFromSliders();
    });

    // Slice selector
    document.querySelectorAll('input[name="slice"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        currentSlice = e.target.value;
        drawLikelihood();
      });
    });

    // View toggle (2D Slice vs Full 3D)
    document.querySelectorAll('.view-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        currentView = btn.dataset.view;
        document.querySelectorAll('.view-btn').forEach(b => {
          b.classList.toggle('active', b.dataset.view === currentView);
        });
        // Show/hide slice selector based on view
        document.getElementById('slice-selector').classList.toggle('hidden', currentView === 'full3d');
        drawLikelihood();
      });
    });

    document.getElementById('algorithm-select').addEventListener('change', (e) => {
      currentAlgorithm = e.target.value;
      updateAlgorithmInfo();
      reset();
    });

    document.getElementById('start-btn').addEventListener('click', () => {
      if (isRunning) {
        isRunning = false;
        document.getElementById('start-btn').textContent = 'Continue';
      } else {
        isRunning = true;
        document.getElementById('start-btn').textContent = 'Pause';
        animate();
      }
    });

    document.getElementById('reset-btn').addEventListener('click', reset);

    // Update algorithm info
    function updateAlgorithmInfo() {
      const info = {
        analytic: {
          name: 'Analytic Solution (OLS)',
          desc: 'Computes the exact MLE using matrix algebra: Œ≤ = (X\'X)‚Åª¬πX\'y. Works for any linear model.'
        },
        newton: {
          name: 'Newton-Raphson',
          desc: 'Uses second derivatives (Hessian) for faster convergence: Œ≤_new = Œ≤ - H‚Åª¬π‚àá‚Ñì. Typically converges in 1-2 steps!'
        },
        gradient: {
          name: 'Gradient Descent',
          desc: 'Follows the gradient in all 3 dimensions simultaneously. Watch the path on the slice view!'
        }
      };

      document.getElementById('algo-name').textContent = info[currentAlgorithm].name;
      document.getElementById('algo-desc').textContent = info[currentAlgorithm].desc;
    }

    // Initialize
    window.addEventListener('resize', () => {
      setupCanvas();
      drawData();
      drawLikelihood();
    });

    setupCanvas();
    generateData();
    updateSliders();
    updateAlgorithmInfo();

    canvas.classList.add('manual-mode');
    updateFromSliders();
  </script>
</body>
</html>
